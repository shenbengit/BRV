{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Usage","text":"<p>This framework is developed without affecting any function components of RecyclerView. This framework will also be maintained continuously.</p> <p></p> <p>Starring/sharing can get more people involved in this open-source project. Click the small pencil icon in the top right corner of the document to directly revise the document \u2197</p> <p></p>"},{"location":"#creating-a-simple-list","title":"Creating a Simple List","text":"<pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre> <p>The keyword \"BRV\" in the code represents this framework, and \"RV\" represents RecyclerView. The \"setup\" function is just a simplification for creating a BindingAdapter object.</p>"},{"location":"#4-ways-to-populate-data-in-the-list","title":"4 Ways to Populate Data in the List","text":"<p>BRV supports 4 ways to populate data. Here, the term \"Model\" is equivalent to data class/JavaBean/POJO.</p>"},{"location":"#1-function-callback","title":"1. Function Callback","text":"<p>Populate data in the \"onBind\" function callback.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nonBind {\nfindView&lt;TextView&gt;(R.id.tv_simple).text = getModel&lt;SimpleModel&gt;().name\n}\n}.models = getData()\n</code></pre>"},{"location":"#2-implement-interface","title":"2. Implement Interface","text":"<p>Implement the \"ItemBind\" interface in the Model class and implement the \"onBind\" function to populate data. This approach is commonly used in many frameworks, such as BRVAH. However, I do not recommend binding views in the Model class, as the Model should only store data and calculation logic and should not contain any UI-related code.</p> <pre><code>class SimpleModel(var name: String = \"BRV\") : ItemBind {\n\noverride fun onBind(holder: BindingAdapter.BindingViewHolder) {\nval appName = holder.context.getString(R.string.app_name)\nholder.findView&lt;TextView&gt;(R.id.tv_simple).text = appName + itemPosition\n}\n}\n</code></pre>"},{"location":"#3-viewbinding","title":"3. ViewBinding","text":"<pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n\nonCreate {\ngetBinding&lt;ItemSimpleBinding&gt;().tvName.text = \"Text Content\"\n}\n\nonBind {\nval binding = getBinding&lt;ItemSimpleBinding&gt;() // Use ViewBinding/DataBinding here\n}\n}.models = getData()\n</code></pre>"},{"location":"#4-databinding","title":"4. DataBinding","text":"<p>Automatically populate data using DataBinding, which is recommended as it requires the least amount of code and provides flexibility.</p>"},{"location":"#a-enable-databinding","title":"a. Enable DataBinding","text":"<p>The first step is to enable the DataBinding framework in the module's <code>build.gradle</code> file.</p> <pre><code>apply plugin: \"kotlin-kapt\" // Apply the kapt plugin for dataBinding\n\nandroid {\n/.../\nbuildFeatures.dataBinding = true\n}\n</code></pre>"},{"location":"#b-declare-variables-in-layout","title":"b. Declare Variables in Layout","text":"<p>The second step is to declare variables in the layout file and bind them to the view elements.</p> <p><pre><code>&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n&lt;data&gt;\n&lt;variable\nname=\"m\"\ntype=\"com.drake.brv.sample.model.SimpleModel\" /&gt;\n&lt;/data&gt;\n\n&lt;LinearLayout\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"&gt;\n\n&lt;FrameLayout\nandroid:id=\"@+id/item\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"100dp\"\nandroid:layout_margin=\"16dp\"\nandroid:background=\"@drawable/bg_card\"\nandroid:foreground=\"?selectableItemBackgroundBorderless\"&gt;\n\n&lt;TextView\nandroid:id=\"@+id/tv_simple\"\nandroid:text=\"@{String.valueOf(m.name)}\"\nandroid:gravity=\"center\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\" /&gt;\n\n&lt;/FrameLayout&gt;\n\n&lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre> The highlighted lines are related to DataBinding usage.</p>"},{"location":"#c-initialize-global-id","title":"c. Initialize Global ID","text":"<pre><code>class App : Application() {\n\noverride fun onCreate() {\nsuper.onCreate()\n\n// Initialize the default binding ID for BindingAdapter; not required if not using DataBinding\nBRV.modelId = BR.m\n}\n}\n</code></pre> <p><code>rv</code> is a list. The <code>models</code> property is a list collection where each element corresponds to an item. DataBinding will automatically bind the elements in the <code>models</code> list to the XML based on the assigned ID.</p> <ol> <li>Note that you need to declare the variable <code>name=\"m\"</code> in some layout or item layout to generate <code>BR.m</code>. Once you declare <code>BRV.model = BR.m</code>, all item layouts used by BRV must use <code>name=\"m\"</code> to declare the data model; otherwise, automatic binding by BRV will not work.  </li> <li>Pay attention to the import of BR from your module. This ensures that all layouts using that ID to declare the data model will be automatically bound by BRV.  </li> <li> <p>If the generated class still does not exist, perform a \"Make Project\" operation (green hammer icon in the toolbar).  </p> </li> <li> <p>The variable <code>m</code> (short for model) can be named anything else, such as <code>model</code> or <code>sb</code>. If you use <code>name=\"data\"</code>, then you should use <code>BR.data</code>. Both <code>BR.data</code> and <code>R.id.data</code> are ID constants and are essentially Int values. You can click to view the BR.m source code.</p> </li> </ol>"},{"location":"#d-building-the-list","title":"d. Building the List","text":"<p>This approach does not require handling data explicitly.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre> <p>Despite the complexity mentioned in the documentation, the DataBinding approach requires the least amount of code and provides the highest decoupling.</p> <p>When using DataBinding, you can copy or reference my commonly used custom attributes: DataBindingComponent.kt If you want to learn more about DataBinding, please read A Complete Guide to DataBinding.</p>"},{"location":"animation/","title":"List Animation","text":"<p>List Animation is used to add animations to the appearance of list items.</p>"},{"location":"animation/#animation-types","title":"Animation Types","text":"<p>You can quickly set several built-in animation types provided by BRV using the following function:</p> <pre><code>fun setAnimation(animationType: AnimationType)\n</code></pre> <p>The available animation types are specified using the <code>AnimationType</code> enum:</p> Enum Animation Description ALPHA Fade-in animation SCALE Scale animation SLIDE_BOTTOM Slide-in from the bottom SLIDE_LEFT Slide-in from the left SLIDE_RIGHT Slide-in from the right"},{"location":"animation/#custom-list-animation","title":"Custom List Animation","text":"<p>If the default animations are not sufficient for your needs, you can customize the desired animation effect by referring to the built-in subclasses of <code>ItemAnimation</code>.</p> <pre><code>fun setAnimation(itemAnimation: ItemAnimation)\n</code></pre> <p>Here is an example using the source code of <code>AlphaItemAnimation</code>:</p> <pre><code>class AlphaItemAnimation @JvmOverloads constructor(private val mFrom: Float = DEFAULT_ALPHA_FROM) : ItemAnimation {\n\noverride fun onItemEnterAnimation(view: View) {\nObjectAnimator.ofFloat(view, \"alpha\", mFrom, 1f).setDuration(300).start() // Fade-in animation\n}\n\ncompanion object {\n\nprivate val DEFAULT_ALPHA_FROM = 0f // Initial opacity\n}\n}\n</code></pre>"},{"location":"checked/","title":"Selection Mode","text":"<p>Editable/multi-select lists are common in development, and with just a few lines of code, BRV can implement a selection mode: Demo</p>"},{"location":"checked/#multi-select-list","title":"Multi-select List","text":"<ol> <li> <p>Create the list:     <pre><code>rv.linear().setup {\naddType&lt;CheckModel&gt;(R.layout.item_check_mode)\n}.models = getData\n</code></pre></p> </li> <li> <p>Add a field to the Model for storing the selection state:     ```kotlin hl_lines=\"2\"     data class CheckModel(         var checked: Boolean = false,         var visibility: Boolean = false     ) : BaseObservable() // BaseObservable is used for DataBinding</p> </li> <li> <p>Listen for selection events:     <pre><code>rv.linear().setup {\naddType&lt;CheckModel&gt;(R.layout.item_check_mode)\nonChecked { position, isChecked, isAllChecked -&gt;\nval model = getModel&lt;CheckModel&gt;(position)\nmodel.checked = isChecked\nmodel.notifyChange() // Notify UI of data changes\n}\n}.models = getData\n</code></pre></p> </li> <li> <p>Trigger the selection event:     <pre><code>rv.linear().setup {\naddType&lt;CheckModel&gt;(R.layout.item_check_mode)\nonChecked { position, isChecked, isAllChecked -&gt;\nval model = getModel&lt;CheckModel&gt;(position)\nmodel.checked = isChecked\nmodel.notifyChange() // Notify UI of data changes\n}\n\nonClick(R.id.cb, R.id.item) {\nvar checked = getModel&lt;CheckModel&gt;().checked\nsetChecked(adapterPosition, !checked) // Trigger the selection event when clicking on a list item to select/deselect it\n}\n}.models = getData\n</code></pre></p> </li> </ol> <p></p>"},{"location":"checked/#default-selection","title":"Default Selection","text":"<p>If you want to default select certain items, you should use the <code>setChecked</code> function instead of directly setting the <code>isChecked</code> property to true in the Model (this won't trigger the selection callback).</p> <p>For example, in the Demo, there is a line of code that defaults to selecting the first item:</p> <pre><code>// Toggle selection mode\ntv_manage.setOnClickListener {\nadapter.toggle()\nrv.bindingAdapter.setChecked(0, true) // Select the first item initially\n}\n</code></pre>"},{"location":"checked/#data-changes","title":"Data Changes","text":"<p>If the data positions change, such as with additions or deletions, use <code>BindingAdapter.checkedPosition.clear()</code> to clear the selected position collection (or perform necessary operations), otherwise data errors may occur, leading to the inability to single-select.</p>"},{"location":"checked/#functions","title":"Functions","text":"<p>Common functions for selection mode support:</p> Function Description allChecked Select or deselect all items singleMode Check if it is in single-selection mode isCheckedAll Check if all items are selected checkedReverse Reverse the selection setChecked Set whether the item at the specified position is selected checkedSwitch Toggle the selection state setCheckableType Specify the type(s) that can be selected getCheckedModels Get the collection of selected data models checkedPosition Collection of positions of selected items checkedCount Number of items selected onChecked Selection callback"},{"location":"click/","title":"Click Event","text":""},{"location":"click/#functions","title":"Functions","text":"Function Description onFastClick Add an event listener for the specified Id onClick Add a click event listener for the specified Id with debounce (prevents repeated clicks within a default interval of 500 milliseconds). You can also set the interval onLongClick Add a long click event listener for the specified Id <p>By using the control's ID in the item's layout file, you can set click or long click events for any view. The click event for an item is added to the root layout of the item by setting its ID.</p>"},{"location":"click/#one-to-many-click-events","title":"One-to-Many Click Events","text":"<p>This approach is useful when multiple IDs need to handle the same click logic.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n\nonClick(R.id.item) {\n// Click event for the item, where the root layout of the item has the ID R.id.item\n}\n}.models = getData()\n</code></pre> <p>The <code>onClick</code> parameter is of variable length. You can specify multiple IDs, and there is an override behavior. The same applies to <code>onFastClick</code> and <code>onLongClick</code>.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n\nonLongClick(R.id.item) {\n\n}\nonClick(R.id.btn_submit) {\n// `it` refers to the ID you set\n}\n\nonClick(R.id.btn_submit) {\n// This will override the previous callback logic because the IDs are the same\n}\n}.models = getData()\n</code></pre>"},{"location":"click/#one-to-one-click-events","title":"One-to-One Click Events","text":"<p>When there is a one-to-one mapping between an ID and a click event callback, you can use the following simplified syntax:</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n\nR.id.tv_simple.onClick {\ntoast(\"Click Text\")\n}\nR.id.item.onLongClick {\ntoast(\"Click Item\")\n}\n}.models = getData()\n</code></pre>"},{"location":"click/#click-debouncing","title":"Click Debouncing","text":"<p>Debouncing: Responding only to the first click within a certain interval, preventing repeated response to click events caused by fast user clicks.</p> <p>Enabling click debouncing in BRV is straightforward. Simply use the <code>onClick</code> function to set the event listener. <code>onFastClick</code> does not include click debouncing.</p> <p>The following code can modify the debounce interval (default is 500 milliseconds):</p> Global Setting <pre><code>BRV.clickThrottle = 1000 // in milliseconds\n</code></pre> Per-instance Setting <p>```kotlin hl_lines=\"2\" binding.rv.linear().setup { clickThrottle = 1000 // override the global setting</p> <pre><code>    addType&lt;SimpleModel&gt;(R.layout.item_simple)\n    R.id.item.onClick {\n        toast(\"Click Text\")\n    }\n}.models = getData()\n```\n</code></pre>"},{"location":"component/","title":"Third-Party Components","text":"<p>The BRV framework does not affect the functionality and usage of the original RecyclerView and its components. Here are some commonly used or recommended third-party frameworks and their usage examples:</p> <p></p> <p>Contributions to this list of extension frameworks are highly welcome. Click the small pencil icon in the top right corner of the document to directly edit this page \u2197</p> <p></p> Framework Description looping-layout Looping scrollable list PathLayoutManager Customizable path-based scrolling for lists ZLayoutManager Tinder-like card stack switching CarouselLayoutManager Card stack switching vertically or horizontally FanLayoutManager Cover flow list PagerGridLayoutManager Grid paged list ZoomRecylerLayout Zoom effect on scrolling list Linkage-RecyclerView Two-level linked list SwipeToActionLayout List with swipe buttons flexbox-layout Google's Flexbox flow layout SpannedGridLayoutManager Rearranges the list based on SpanSize to fill the space"},{"location":"divider-grid/","title":"Grid List","text":"<p>Support for GridLayoutManager with grid layout dividers.</p>"},{"location":"divider-grid/#horizontal-dividers","title":"Horizontal Dividers","text":"<pre><code>rv.grid(3).divider(R.drawable.divider_horizontal).setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#vertical-dividers","title":"Vertical Dividers","text":"<pre><code>rv.grid(3, RecyclerView.HORIZONTAL)\n.divider(R.drawable.divider_vertical, DividerOrientation.VERTICAL)\n.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#grid-dividers","title":"Grid Dividers","text":"<pre><code>rv.grid(3).divider {\nsetDrawable(R.drawable.divider_horizontal)\norientation = DividerOrientation.GRID\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#edge-dividers","title":"Edge Dividers","text":"<p>You can control whether edge dividers are visible using two fields:</p> Field Description startVisible Whether to show top and bottom edge dividers endVisible Whether to show left and right edge dividers includeVisible Whether to show surrounding dividers"},{"location":"divider-grid/#1-top-and-bottom","title":"1) Top and Bottom","text":"<pre><code>rv.grid(3).divider {\nsetDrawable(R.drawable.divider_horizontal)\norientation = DividerOrientation.GRID\nstartVisible = true\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#2-left-and-right","title":"2) Left and Right","text":"<pre><code>rv.grid(3).divider {\nsetDrawable(R.drawable.divider_horizontal)\norientation = DividerOrientation.GRID\nendVisible = true\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#3-all-edges","title":"3) All Edges","text":"<pre><code>rv.grid(3).divider {\nsetDrawable(R.drawable.divider_horizontal)\norientation = DividerOrientation.GRID\nstartVisible = true\nendVisible = true\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#divider-spacing","title":"Divider Spacing","text":"<p>By default, dividers are based on the spacing</p> <p>set for the RecyclerView.</p> <p></p> <pre><code>binding.rv.grid(3, orientation = RecyclerView.VERTICAL).divider {\norientation = DividerOrientation.GRID\nsetDivider(1, true)\nsetMargin(16, 16, dp = true)\nsetColor(Color.WHITE)\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}.models = getData()\n</code></pre> <p> You can set spacing based on the item using the <code>baseItemStart/baseItemEnd</code> parameters.</p> <pre><code>binding.rv.grid(3, orientation = RecyclerView.VERTICAL).divider {\norientation = DividerOrientation.GRID\nsetDivider(1, true)\nsetMargin(16, 16, dp = true, baseItemStart = true)\nsetColor(Color.WHITE)\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}.models = getData()\n</code></pre>"},{"location":"divider-grid/#grid-sticky-equally-spaced-dividers","title":"Grid Sticky Equally Spaced Dividers","text":"<p>For this requirement, it is recommended to use a nested list to avoid issues with dividers. This approach is commonly used to achieve this effect.</p> <pre><code>binding.rv.linear().setup {\nonCreate {\nif (itemViewType == R.layout.item_simple_list) { // Build nested grid list\nfindView&lt;RecyclerView&gt;(R.id.rv).divider { // Build spacing\nsetDivider(20)\nincludeVisible = true\norientation = DividerOrientation.GRID\n}.grid(2).setup {\naddType&lt;Model&gt;(R.layout.item_group_none_margin)\n}\n}\n}\nonBind {\nif (itemViewType == R.layout.item_simple_list) { // Set data for nested grid list\nfindView&lt;RecyclerView&gt;(R.id.rv).models =\ngetModel&lt;NestedGroupModel&gt;().itemSublist\n}\n}\naddType&lt;NestedGroupModel&gt;(R.layout.item_simple_list)\naddType&lt;HoverHeaderModel&gt;(R.layout.item_hover_header)\n}.models = getData()\n</code></pre>"},{"location":"divider-linear/","title":"Linear List","text":"<p>If you prefer to directly create item layouts with XML to achieve the divider effect, using simple <code>layout_margin</code> for spacing, I recommend using <code>layout_margin</code>.</p>"},{"location":"divider-linear/#horizontal-divider","title":"Horizontal Divider","text":"<p>Create a <code>drawable</code> file to describe the divider, which can be reused:</p> <pre><code>&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n&lt;solid android:color=\"@color/dividerDecoration\" /&gt;\n&lt;size android:height=\"5dp\" /&gt;\n&lt;/shape&gt;\n</code></pre> <p>Create the list:</p> <pre><code>rv.linear().divider(R.drawable.divider_horizontal).setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider)\n}.models = getData()\n</code></pre> <p></p>"},{"location":"divider-linear/#vertical-divider","title":"Vertical Divider","text":"<p>Create a drawable as the divider:</p> <pre><code>&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n&lt;solid android:color=\"@color/dividerDecoration\" /&gt;\n&lt;size android:width=\"5dp\" /&gt;\n&lt;/shape&gt;\n</code></pre> <p>Create the list:</p> <pre><code>rv.linear(RecyclerView.HORIZONTAL).divider(R.drawable.divider_vertical).setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}.models = getData()\n</code></pre> <ul> <li>Here, a <code>Drawable</code> resource is used to quickly set the divider. The width and height of the Drawable determine the width and height of the divider.</li> <li>For horizontal dividers, the width value of the Drawable is ignored (the actual width is determined by the RecyclerView's width).</li> <li>For vertical dividers, the height value of the Drawable is ignored (the actual height of the divider is determined by the RecyclerView's height).</li> </ul>"},{"location":"divider-linear/#edge-dividers","title":"Edge Dividers","text":"Field Description startVisible Indicates whether the start divider is visible endVisible Indicates whether the end divider is visible includeVisible Indicates whether both start and end dividers are visible <p>You can control the visibility of the start and end dividers using the two fields:</p> <pre><code>rv.linear().divider {\nsetDrawable(R.drawable.divider_horizontal)\nstartVisible = true\nendVisible = true\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre>"},{"location":"divider-linear/#full-wrap-dividers","title":"Full Wrap Dividers","text":"<p>This type of divider is called a grid divider and requires the use of <code>DividerOrientation.GRID</code>, which is not supported by LinearLayoutManager.</p> <p>There are two ways to achieve this:</p> <ol> <li>Use a GridLayoutManager with a spanCount of 1.</li> <li>Use separate <code>View</code>s on both sides of</li> </ol> <p>the RecyclerView to draw the dividers.</p> <p>The first method is recommended. Here's an example:</p> <pre><code>rv.grid().divider {\nsetDrawable(R.drawable.divider_horizontal)\norientation = DividerOrientation.GRID\nincludeVisible = true\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}.models = getData()\n</code></pre>"},{"location":"divider-linear/#divider-spacing","title":"Divider Spacing","text":"<p>There are two ways to add spacing to the dividers:</p> <ol> <li> <p>Directly configure a <code>drawable</code> with the desired margin. Here's an example of a horizontal divider with a 16dp margin:</p> <pre><code>&lt;inset xmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:insetLeft=\"16dp\"\nandroid:insetRight=\"16dp\"&gt;\n&lt;shape&gt;\n&lt;solid android:color=\"@color/dividerDecoration\" /&gt;\n&lt;size android:height=\"5dp\" /&gt;\n&lt;/shape&gt;\n&lt;/inset&gt;\n</code></pre> </li> <li> <p>Use <code>setMargin()</code>:</p> <pre><code>binding.rv.linear().divider {\nsetDivider(1, true)\nsetMargin(16, 0, dp = true)\nsetColor(Color.WHITE)\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}\n</code></pre> </li> </ol>"},{"location":"divider-other/","title":"Custom","text":"<ol> <li>The <code>divider</code> functions in BRV are implemented by creating a <code>DefaultDecoration</code>. If you want to access more functionality, please refer to the public functions in that class.</li> <li>If the built-in divider functionality doesn't meet your requirements, you can inherit from <code>RecyclerView.ItemDecoration</code> to implement your own divider.</li> </ol>"},{"location":"divider-other/#combining-spacing","title":"Combining Spacing","text":"<p>You can repeatedly call <code>.divider</code> to stack multiple divider and spacing settings:</p> <pre><code>binding.rv.grid(3).divider { // Horizontal spacing\norientation = DividerOrientation.HORIZONTAL\nsetDivider(10, true)\n}.divider { // Vertical spacing\norientation = DividerOrientation.VERTICAL\nsetDivider(20, true)\nonEnabled { // Enable dividers only for specific item type\nitemViewType == R.layout.item_divider_vertical\n}\n}.setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_vertical)\n}.models = getData()\n</code></pre>"},{"location":"divider-other/#methods","title":"Methods","text":"Function Description onEnabled Specifies whether the divider is enabled for the current item addType Specifies that dividers should only be drawn for the added item types setColor Sets the color of the divider setDrawable Sets the drawable resource for the divider setBackground Sets the background color of the divider setMargin Sets the spacing for the divider"},{"location":"divider-other/#computing-edges","title":"Computing Edges","text":"<p>There is a utility class available to calculate the edge position of an item within the list. This can be used to set spacing. The <code>Edge.computeEdge()</code> function returns an <code>Edge</code> object:</p> <pre><code>data class Edge(\nvar left: Boolean = false,\nvar top: Boolean = false,\nvar right: Boolean = false,\nvar bottom: Boolean = false\n)\n</code></pre> <p>If <code>left</code> is <code>true</code>, it indicates that the specified position is at the left edge of the list. Similarly, <code>top</code> being <code>true</code> indicates the item is at the top edge, and so on. You can use the results of this calculation to set the spacing for the itemView.</p>"},{"location":"divider-staggerd/","title":"Staggered Grid List","text":"<p>Waterfall Flow Divider</p> <p></p> <pre><code>rv.staggered(3).divider(R.drawable.divider_horizontal).setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n\nonBind {\n// Simulate dynamic height\nval layoutParams = itemView.layoutParams\nlayoutParams.height = getModel&lt;DividerModel&gt;().height\nitemView.layoutParams = layoutParams\n}\n}.models = getData()\n</code></pre>"},{"location":"divider-staggerd/#edge-divider","title":"Edge Divider","text":"<p>You can control the visibility of edge dividers using two fields:</p> Field Description startVisible Determines if top and bottom edge dividers are visible endVisible Determines if left and right edge dividers are visible includeVisible Determines if edge dividers around the layout are visible"},{"location":"drag/","title":"Drag and Drop","text":"<p>To enable drag and drop functionality, implement the <code>ItemDrag</code> interface for your data model:</p> <pre><code>data class DragModel(override var itemOrientationDrag: Int = ItemOrientation.ALL) : ItemDrag\n</code></pre> <p>Note that if your data model is deserialized using Gson, it will remove all field initialization values. To ensure the value is always returned, you can override the accessor function:</p> <pre><code>class DragModel() : ItemDrag {\noverride var itemOrientationDrag: Int = 0\nget() = ItemOrientation.ALL // Always return this value\n}\n</code></pre>"},{"location":"drag/#itemorientation","title":"ItemOrientation","text":"<p>The <code>ItemOrientation</code> class includes configurable drag directions:</p> Field Description <code>ALL</code> All directions <code>VERTICAL</code> Vertical direction <code>HORIZONTAL</code> Horizontal direction <code>LEFT</code> Left direction <code>RIGHT</code> Right direction <code>UP</code> Up direction <code>DOWN</code> Down direction <code>NONE</code> Disabled"},{"location":"drag/#customization","title":"Customization","text":"<p>If you want to extend <code>ItemTouchHelper</code> or listen to its events, you can assign a value to the <code>itemTouchHelper</code> variable in the <code>BindingAdapter</code>:</p> <pre><code>rv.linear().setup {\naddType&lt;Model&gt;(R.layout.item)\n\nitemTouchHelper = ItemTouchHelper(object : DefaultItemTouchCallback(this) {\n\n/**\n         * Called when the drag action is completed and the finger is released.\n         */\nopen fun onDrag(\nsource: BindingAdapter.BindingViewHolder,\ntarget: BindingAdapter.BindingViewHolder\n) {\n// This is called after the drag and drop operation, you can synchronize with the server here\n}\n\n})\n\n}.models = data\n</code></pre> <p>Note that <code>DefaultItemTouchCallback</code> is the default touch event handling in BRV. You can override it or directly use <code>ItemTouchHelper.Callback</code>.</p>"},{"location":"drag/#click-and-drag","title":"Click and Drag","text":"<p>Directly clicking on an item to start dragging can cause gesture conflicts because both scrolling the list and dragging for sorting require movement gestures. Therefore, it is recommended to initiate dragging from a small icon within the item (dragging the icon will scroll the list).</p> <p>Here's an example code:</p> <pre><code>rv.linear().setup {\naddType&lt;DragModel&gt;(R.layout.item_drag)\nonBind {\nfindView&lt;View&gt;(R.id.btnDrag).setOnTouchListener { _, event -&gt;\nif (event.action == MotionEvent.ACTION_DOWN) { // Start dragging when the finger is pressed\nitemTouchHelper?.startDrag(this)\n}\ntrue\n}\n}\n}.models = getData()\n</code></pre>"},{"location":"extension/","title":"Extension Functions","text":""},{"location":"extension/#recyclerview","title":"RecyclerView","text":"<p>Here are some commonly used calls for <code>BindingAdapter</code>:</p> Function Description <code>bindingAdapter</code> Returns the object if the adapter is a <code>BindingAdapter</code>, otherwise throws an exception. <code>models</code> Data model collection. No need to execute <code>notify*</code> functions, it automatically refreshes using <code>notifyDataChanged</code>. <code>_data</code> Similar to <code>models</code>, but it doesn't automatically refresh using <code>notifyDataChanged</code>. <code>mutable</code> Read-only data model collection that allows addition and removal. You need to manually refresh the list using <code>notify*</code> functions. If the actual data is not assigned, this function will throw an exception. <code>addModels</code> Adds data and automatically refreshes the list."},{"location":"extension/#layout-managers","title":"Layout Managers","text":"<p>The framework also provides extension functions for quickly creating layout managers. Here are the examples shown above:</p> LinearLayoutManager <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre> GridLayoutManager <pre><code>rv.grid(3).setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre> StaggeredLayoutManager <pre><code>rv.staggered(3).setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre> <p>Related Functions:</p> Function Description <code>linear</code> Creates a linear list using <code>LinearLayoutManager</code>. <code>grid</code> Creates a grid list using <code>GridLayoutManager</code>. <code>staggered</code> Creates a staggered grid list using <code>StaggeredLayoutManager</code>."},{"location":"extension/#dividers","title":"Dividers","text":"<p>The framework provides an extension function for quickly setting dividers:</p> <pre><code>rv.linear().divider(R.drawable.divider_horizontal).setup {\naddType&lt;DividerModel&gt;(R.layout.item_divider_horizontal)\n}.models = getData()\n</code></pre> <p>The extension function actually uses the <code>DefaultDecoration</code> to create the object.</p>"},{"location":"extension/#dialogs","title":"Dialogs","text":"<p>Quickly create a list in a dialog using the extension function:</p> <pre><code>Dialog(activity).setAdapter(bindingAdapter).show()\n</code></pre> <p>Function: <pre><code>fun Dialog.brv(block: BindingAdapter.(RecyclerView) -&gt; Unit): Dialog\n</code></pre></p>"},{"location":"flexbox/","title":"Flexbox Layout","text":"<p>To implement flexible layouts in BRV, you can add the Google open-source library flexbox-layout.</p> <p>Add the dependency to your project:</p> <pre><code>dependencies {\nimplementation 'com.google.android.flexbox:flexbox:3.0.0'\n}\n</code></pre> <p>Then, create a list:</p> <p></p> <pre><code>rv.layoutManager = FlexboxLayoutManager(activity)\n\nrv.setup {\naddType&lt;FlexTagModel&gt;(R.layout.item_flex_tag)\n}.models = getData()\n</code></pre> <p>In this example, <code>FlexboxLayoutManager</code> is set as the layout manager for the <code>RecyclerView</code>. You can then use the <code>setup</code> function to configure your list, specifying the type and layout resource for the items. Finally, assign the data to the <code>models</code> property to populate the list.</p>"},{"location":"group/","title":"Grouping","text":"<p>BRV provides several features for handling expandable groups in a RecyclerView. These features include expand/collapse functionality, animations, recursive expansion/collapse, expanding groups to the top, ensuring only one group is expanded at a time, finding the parent group of an item, and supporting multiple group types.</p> <p>To use these features, you need to implement the <code>ItemExpand</code> interface in your model class:</p> <pre><code>class GroupModel : ItemExpand {\noverride var itemGroupPosition: Int = 0\noverride var itemExpand: Boolean = false\noverride var itemSublist: List&lt;Any?&gt;? = listOf(Model(), Model(), Model(), Model())\n}\n</code></pre> <p>The <code>itemGroupPosition</code> represents the position of the item within its group, <code>itemExpand</code> indicates whether the item is expanded or collapsed, and <code>itemSublist</code> stores the sublist of the group.</p> <p>To create the expandable group list, you can use the following code:</p> <pre><code>rv.linear().setup {\naddType&lt;GroupModel&gt;(R.layout.item_group_title)\n\nR.id.item.onClick {\nexpandOrCollapse()\n}\n}.models = getData()\n</code></pre> <p>In this example, the <code>addType</code> function is used to specify the type of the group item and its corresponding layout resource. The <code>R.id.item.onClick</code> block sets up a click listener for the item to expand or collapse it. The <code>getData()</code> function provides the list of data models.</p> <p>To handle nested groups, you can customize the behavior of the item touch helper for drag and swipe actions. For example:</p> <pre><code>binding.rv.linear().setup {\nitemTouchHelper = ItemTouchHelper(object : DefaultItemTouchCallback() {\noverride fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) {\nif (actionState == ItemTouchHelper.ACTION_STATE_DRAG) {\n(viewHolder as BindingAdapter.BindingViewHolder).collapse()\n}\nsuper.onSelectedChanged(viewHolder, actionState)\n}\n\noverride fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {\n(viewHolder as BindingAdapter.BindingViewHolder).collapse()\nsuper.onSwiped(viewHolder, direction)\n\nval parentViewHolder = vh.findParentViewHolder()\nval parentGroup = parentViewHolder?.getModelOrNull&lt;ItemExpand&gt;()\n(parentGroup?.itemSublist as? ArrayList)?.remove(vh.getModelOrNull())\n}\n})\n\n// ...\n}.models = getData()\n</code></pre> <p>This code demonstrates how to collapse the sublist of a group before dragging or swiping actions to avoid data inconsistency. The <code>findParentViewHolder()</code> function is used to find the parent group's ViewHolder, and the sublist is removed from the parent group's <code>itemSublist</code> if a nested item is swiped.</p> <p>You can expand or collapse all groups by iterating over the data and setting the <code>itemExpand</code> property:</p> <pre><code>binding.rv.bindingAdapter.models = getData().forEach {\nit.itemExpand = true // or false to collapse all\n}\n</code></pre> <p>The <code>ItemDepth</code> interface and <code>ItemDepth.refreshItemDepth</code> function can be used to calculate the depth of items in the list. This can be helpful for managing hierarchical groups.</p> <p>For more detailed examples and explanations of the features, you can refer to the provided code snippets and the official documentation of the BRV library.</p>"},{"location":"header_footer/","title":"Header/Footer Layout","text":"<p>The provided code demonstrates how to add header and footer layouts to a RecyclerView using the BRV library:</p> <ol> <li>Both the header and footer layouts are considered as items within the RecyclerView, so when calculating the position, you need to take them into account.</li> <li>You need to use the <code>addType</code> function to add types for the header and footer layouts.</li> </ol> <p>Here's an example of how to add header and footer layouts using BRV:</p> <pre><code>binding.rv.linear().setup {\naddType&lt;Model&gt;(R.layout.item_simple)\n\n/**\n     * The BRV data set = Header + Footer + Models\n     * So essentially, the header and footer layouts are just another group of multiple types.\n     * Separating them out is to facilitate the replacement of Models without affecting the Header and Footer.\n     */\n\naddType&lt;Header&gt;(R.layout.item_header)\naddType&lt;Footer&gt;(R.layout.item_footer)\n}.models = getData()\n\nbinding.rv.bindingAdapter.addHeader(Header(), animation = true)\nbinding.rv.bindingAdapter.addFooter(Footer(), animation = true)\n</code></pre> <p>If you don't want the default page to overlap with the header, you can use the following solutions:</p> <ol> <li>If you don't want the default page to cover the header, you can use the <code>CoordinatorLayout</code> to implement the header effect. The default page functionality of <code>PageRefreshLayout</code> can cause the entire list to be covered by the default page.</li> <li>If you only want to prevent the header or footer from interfering with BRV, you can use ConcatAdapter to achieve it.</li> <li>You can use a <code>ScrollView/NestedScrollView</code> to nest the RecyclerView to implement the header, but it will cause the RecyclerView to lose the item reuse effect. If there is a large amount of data in the list, it may cause lag (if the data volume is small, this can be ignored).</li> </ol>"},{"location":"header_footer/#partial-empty-state-for-the-list","title":"Partial Empty State for the List","text":"<p>If you are using the <code>CoordinatorLayout</code> solution to address the issue of the empty state overlapping the header, but you want the pull-to-refresh to start from the top of the page, you can refer to the implementation code in the demo's <code>PageNestedHeaderFragment</code>. Manually specify the empty state to avoid overlapping the header.</p> <pre><code>&lt;com.drake.brv.PageRefreshLayout\nandroid:id=\"@+id/page\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\napp:page_rv=\"@id/rv\"\napp:page_state=\"@id/state\"/&gt;\n</code></pre> <ol> <li>Use the <code>app:page_rv</code> attribute to specify the nested RecyclerView.</li> <li>Use the <code>app:page_state</code> attribute to specify the nested empty state.</li> </ol>"},{"location":"header_footer/#functions","title":"Functions","text":"Function Description addHeader / addFooter Add a header layout or a footer layout. removeHeader / removeFooter Remove the header layout or the footer layout. removeHeaderAt / removeFooterAt Remove the header layout or the footer layout at the specified index. clearHeader / clearFooter Clear all header layouts or footer layouts. isHeader / isFooter Check if the specified index is a header layout or a footer layout. headerCount / footerCount Get the count of header layouts or footer layouts."},{"location":"hover/","title":"Hover","text":"<p>To achieve the sticky header effect, you can implement the <code>ItemHover</code> interface:</p> <pre><code>class HoverHeaderModel : ItemHover {\noverride var itemHover: Boolean = true\n}\n</code></pre> <p>By setting <code>itemHover</code> to <code>true</code>, the item will stick to the top.</p> <p>Here's a complete example:</p> <pre><code>override fun onActivityCreated(savedInstanceState: Bundle?) {\nsuper.onActivityCreated(savedInstanceState)\n\nrv.linear().setup {\naddType&lt;Model&gt;(R.layout.item_simple)\naddType&lt;HoverHeaderModel&gt;(R.layout.item_hover_header)\nmodels = getData()\n\n// Click event\nonClick(R.id.item) {\nwhen (itemViewType) {\nR.layout.item_hover_header -&gt; toast(\"Sticky item\")\nelse -&gt; toast(\"Regular item\")\n}\n}\n\n// Optional: Sticky listener\nonHoverAttachListener = object : OnHoverAttachListener {\n// When attaching to the top, v represents the sticky itemView\noverride fun attachHover(v: View) {\nViewCompat.setElevation(v, 10F)\n}\n\n// When detaching from the top\noverride fun detachHover(v: View) {\nViewCompat.setElevation(v, 0F)\n}\n}\n\n}\n}\n</code></pre> <p>Unlike most sticky frameworks, BRV doesn't require special handling to support all click events.</p> <p>[BindingAdapter]: Determine if the current position belongs to a sticky item</p> <pre><code>fun isHover(position: Int): Boolean\n</code></pre>"},{"location":"hover/#sticky-grid","title":"Sticky Grid","text":"<p>Demo screenshot:</p> <p></p> <p>As shown in the image, the sticky item is twice as wide as regular items. To achieve this, you need to dynamically determine the <code>SpanSize</code> of the sticky item, so you can't directly use <code>grid(3)</code>. Instead, you need to create a <code>HoverGridLayoutManager</code> manually:</p> <pre><code>val layoutManager = HoverGridLayoutManager(requireContext(), 2)\nlayoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {\noverride fun getSpanSize(position: Int): Int {\nreturn if(rv.bindingAdapter.isHover(position)) 2 else 1 // Specific business logic should be determined by you\n}\n}\nrv.layoutManager = layoutManager\n</code></pre>"},{"location":"issues/","title":"FAQ","text":""},{"location":"issues/#faq","title":"FAQ","text":"<ul> <li>Can it be used in Java?</li> <li>Crash caused by data class in grouping and collapsing</li> <li>Support for ViewBinding</li> <li>Adaptation for Paging3</li> <li>Failed to delete item</li> <li>Click event not working with fast list refreshing</li> <li>Support for updating the list with DiffUtil</li> <li>Failed to compile SmartRefreshLayout dependency</li> <li>Implementation of onViewAttachedToWindow/onViewDetachedFromWindow callbacks</li> <li>Filtering data using Filter</li> <li>How to implement infinite scrolling in the list</li> <li>Support for both top and bottom paging with preloading</li> <li>CoordinatorLayout scrolling issue after showing empty page</li> <li>Maintaining selection state after pull-to-refresh</li> <li>Issue with multi-language support during pull-to-load</li> <li>Automatically load the second page if the first page items don't fill the entire screen</li> <li>Top layout gets pushed up during pull-to-load</li> <li>Request for implementation approach for swipe background</li> </ul>"},{"location":"item/","title":"Data Interfaces","text":"<p>The data for the RecyclerView is a collection of <code>List&lt;Any?&gt;?</code>, where the collection elements are data models.</p> <p>By having the data models implement different interfaces, you can obtain different functionalities or callbacks.</p> Interface Description ItemBind Callback in the data model's <code>onBindViewHolder</code> lifecycle, used for data binding. ItemAttached Listens to the view being attached to the window. ItemExpand Indicates that the item can be grouped. ItemDrag Indicates that the item can be dragged. ItemSwipe Indicates that the item can be swiped. ItemHover Indicates that the item can be hovered. ItemPosition Represents the index position of the item. <p>Please refer to the corresponding feature sections or comments for specific usage.</p> <pre><code>data class SimpleModel(var name: String = \"BRV\") : ItemBind {\n\noverride fun onBind(holder: BindingAdapter.BindingViewHolder) {\n// Use different methods to access the view components\n// holder.findView&lt;TextView&gt;(R.id.tv_simple).text = appName // Using findById\n// val binding = holder.getBinding&lt;ItemMultiTypeOneBinding&gt;() // Using DataBinding or ViewBinding\n}\n}\n</code></pre>"},{"location":"lifecycle/","title":"Lifecycle","text":""},{"location":"lifecycle/#lifecycle","title":"Lifecycle","text":"<p>First, let's start with some basic knowledge about RecyclerView (referred to as \"rv\" for short).</p> <ol> <li>onCreateViewHolder (Create View): This callback is invoked to create the view. The number of times it is called is equal to the number of items that can be displayed on the screen simultaneously. If you need to frequently manipulate the view, it is recommended to do it in this callback.</li> <li>onBindViewHolder (Bind Data): This callback is invoked every time an item is displayed on the screen. Therefore, it will be called repeatedly during fast scrolling of the list. It is recommended not to perform time-consuming operations inside this callback. For example, it is suggested to use Serialize for efficient storage instead of SharedPreferences.</li> </ol> <p>In BRV, these two functions are simplified as follows:</p> Function Description onCreate Corresponds to the <code>onCreateViewHolder</code> callback in the Adapter. onBind Corresponds to the <code>onBindViewHolder</code> callback in the Adapter. onBindViewHolders A collection of <code>onBindViewHolder</code> listeners, usually used by other frameworks for extension. Users generally do not need to use this directly."},{"location":"lifecycle/#note","title":"Note","text":"<p>BindingAdapter is an <code>open class</code> and can be inherited and overridden. Any missing callback functions can be implemented by inheritance or anonymous class.</p> <pre><code>binding.rv.linear().adapter = object : BindingAdapter() {\noverride fun onViewRecycled(holder: BindingViewHolder) {\nsuper.onViewRecycled(holder)\n// ....\n}\n}.apply {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nmodels = getData()\n}\n</code></pre> <p>Only the most recent <code>onBind</code> or <code>onCreate</code> callback is effective. There is a hierarchy of overrides.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nonCreate {\nwhen(itemViewType){\nR.layout.item_simple -&gt; {\n// Special handling\n}\n}\n}\n}.models = getData()\n</code></pre>"},{"location":"lifecycle/#showhide","title":"Show/Hide","text":"<p>By implementing the <code>ItemAttached</code> interface in the data model, you can be notified when an item is displayed or hidden. For example, item animations can be triggered when an item is displayed.</p> <pre><code>data class SimpleModel(var name: String = \"BRV\") : ItemAttached {\n\nvar visibility: Boolean = false // Show/hide\n\noverride fun onViewAttachedToWindow(holder: BindingAdapter.BindingViewHolder) {\nvisibility = true\n}\n\noverride fun onViewDetachedFromWindow(holder: BindingAdapter.BindingViewHolder) {\nvisibility = false\n}\n}\n</code></pre> <p>Alternatively, you can directly inherit from <code>BindingAdapter</code> to achieve the same result.</p>"},{"location":"multi-type/","title":"Multi-type","text":"<p>In BRV, creating multiple types is very simple. You can add multiple types by calling <code>addType()</code> multiple times.</p>"},{"location":"multi-type/#adding-multiple-types","title":"Adding Multiple Types","text":""},{"location":"multi-type/#many-to-many","title":"Many-to-Many","text":"<p>Each data type in the list corresponds to an item type.</p> <pre><code>rv.linear().setup {\n\naddType&lt;Model&gt;(R.layout.item_1)\naddType&lt;Store&gt;(R.layout.item_2)\n\n}.models = data\n</code></pre>"},{"location":"multi-type/#one-to-many","title":"One-to-Many","text":"<p>All data types in the list are the same, but different item types are added based on a specific field in the data class.</p> <pre><code>rv.linear().setup {\n\naddType&lt;Model&gt;{\n// Use age to determine different layouts\nwhen (age) {\n23 -&gt; {\nR.layout.item_1\n}\nelse -&gt; {\nR.layout.item_2\n}\n}\n}\n\n}.models = data\n</code></pre> <p>The lambda inside the <code>addType</code> represents the specified generic type, so we can directly use <code>Model.age</code> to determine different types.</p>"},{"location":"multi-type/#interface-implementation","title":"Interface Implementation","text":"<p>You can add a type for an interface and then add multiple subclasses of that interface as data models. Each subclass can implement the interface differently.</p> <p>Example:</p> <pre><code>interface BaseInterfaceModel {\nvar text: String\n}\n\ndata class InterfaceModel1(override var text: String) : BaseInterfaceModel\n\ndata class InterfaceModel2(val otherData: Int, override var text: String) : BaseInterfaceModel\n\ndata class InterfaceModel3(val otherText: String) : BaseInterfaceModel {\noverride var text: String = otherText\n}\n</code></pre> <p>Create sample data:</p> <pre><code>private fun getData(): List&lt;Any&gt; {\nreturn List(3) { InterfaceModel1(\"item $it\") } +\nList(3) { InterfaceModel2(it, \"item ${3 + it}\") } +\nList(3) { InterfaceModel3(\"item ${6 + it}\") }\n}\n</code></pre> <p>Declare the list:</p> <pre><code>binding.rv.linear().setup {\naddType&lt;BaseInterfaceModel&gt;(R.layout.item_interface_type)\nR.id.item.onClick {\ntoast(\"Click on the text\")\n}\n}.models = getData()\n</code></pre> <p>This is just a simple example with text. You can implement more complex business logic based on your requirements.</p>"},{"location":"multi-type/#differentiating-types","title":"Differentiating Types","text":"<p>As mentioned in the previous sections, each item type has its corresponding data type. Therefore, when performing business logic on the data, we need to handle different types differently.</p> <p>Differentiate types based on <code>itemViewType</code>:</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\naddType&lt;ItemSimpleBinding2&gt;(R.layout.item_simple)\nonBind {\nwhen(itemViewType) {\nR.layout.item_simple -&gt; {\ngetBinding&lt;ItemSimpleBinding&gt;().tvName.text = \"Text content\"\n}\nR.layout.item_simple_2 -&gt; {\ngetBinding&lt;ItemSimpleBinding2&gt;().tvName.text = \"Type 2 - Text content\"\n}\n}\n}\n}.models = getData()\n</code></pre> <p>Differentiate types based on <code>getBinding()</code>:</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\naddType&lt;ItemComplexBinding&gt;(R.layout.item_simple)\nonBind {\nwhen (val viewBinding = getBinding&lt;ViewBinding&gt;()) {\nis ItemSimpleBinding -&gt; {\nviewBinding.tvName.text = \"Text content\"\n}\nis ItemComplexBinding -&gt; {\nviewBinding.tvName.text = \"Type 2 - Text content\"\n}\n}\n}\n}.models = getData()\n</code></pre> <p>Differentiate types based on <code>getModel()</code>:</p> <pre><code>rv.linear().setup\n\n{\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\naddType&lt;ItemComplexBinding&gt;(R.layout.item_simple)\nonBind {\nwhen (val model = getModel&lt;Any&gt;()) {\nis ChatModel -&gt; {\nmodel.input = \"Message content\"\nmodel.notifyChange()\n}\nis CommentModel -&gt; {\nmodel.input = \"Comment content\"\nmodel.notifyChange()\n}\n}\n}\n}.models = getData()\n</code></pre>"},{"location":"net/","title":"Network Requests","text":"<p>BRV can be integrated with Net to enhance its functionality in terms of network requests and asynchronous tasks.</p> <p>To integrate Net into your project, you need to add the Net dependency to your project's build.gradle file:</p> <pre><code>dependencies {\nimplementation 'com.github.liangjingkanji:Net:&lt;version&gt;'\n}\n</code></pre> <p>Replace <code>&lt;version&gt;</code> with the specific version of Net you want to use. It's recommended to use a specific version instead of the <code>+</code> symbol to ensure stability.</p> <p>With Net integration, you can leverage the following features:</p> <ul> <li>Auto Refresh: Automatically trigger pull-to-refresh functionality in the RecyclerView.</li> <li>Auto Paging: Automatically load more data when scrolling reaches the end of the RecyclerView.</li> <li>Auto State: Automatically handle empty, loading, and error states in the RecyclerView.</li> </ul> <p>By combining BRV with Net, you can create a powerful and efficient solution for handling network requests and providing a seamless user experience.</p>"},{"location":"performance/","title":"Smooth Scrolling","text":"<p>First of all, I assume you have already read the lifecycle documentation on the basics of RecyclerView. Under normal circumstances, the list should not experience lag even without implementing the optimization methods discussed in this chapter.</p> <p>BRV does not have any performance impact on RecyclerView. The optimization points mentioned here are specific to RecyclerView. For other optimizations, please refer to additional resources or suggestions.</p> <p>Performance optimization is mainly about avoiding time-consuming operations during list scrolling, and <code>onBind</code> is a callback that gets triggered frequently during the scrolling process.</p>"},{"location":"performance/#main-thread-data-readwrite","title":"Main Thread Data Read/Write","text":"<p>SharePreferences (referred to as sp) is a built-in key-value storage tool in Android. Although it allows convenient data read/write on the main thread, its performance is not satisfactory. If you read large-sized sp data in <code>onBind</code>, it can lead to list lagging or even ANR (Application Not Responding) issues.</p> <p>While many suggestions online recommend using MMKV as an alternative, I recommend using Serialze, which is a more efficient and convenient wrapper based on MMKV.</p>"},{"location":"performance/#nested-lists","title":"Nested Lists","text":"<p>When using a RecyclerView within another RecyclerView, it is advisable to set the view for the nested RecyclerView in the <code>onCreate</code> callback (using <code>rv.setup</code>). This helps avoid excessive creation of RecyclerView instances of the same type, which can lead to increased memory consumption. The data for the nested RecyclerView can be bound in <code>onBind</code> using <code>rv.models</code>.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n\nonCreate {\nval rv = findView&lt;RecyclerView&gt;(R.id.rv_check_mode)\nrv.linear().setup { // Setting the view in onCreate avoids repeated callbacks during list scrolling\naddType&lt;NestedModel&gt;(R.layout.item_simple_nested)\n}\n}\n\nonBind {\nval rv = findView&lt;RecyclerView&gt;(R.id.rv_check_mode)\nrv.models = getModel&lt;Model&gt;().listNested // Only onBind can access the data\n}\n}\n</code></pre> <p>Since the nested RecyclerView cannot reuse items, it is recommended to use <code>recycledViewPool</code> for recycling. You can search for specific keywords for more details.</p> <p>If the nested list is very simple, you may not need to consider reuse optimization. In fact, dynamically adding views using <code>addView</code> might be simpler than using a nested list.</p>"},{"location":"performance/#view-additionremoval","title":"View Addition/Removal","text":"<p>To avoid frequent main thread operations such as <code>addView</code> and <code>removeView</code> on views, it is recommended to:</p> <ol> <li>Use <code>visibility</code> to control view visibility.</li> <li>Check if the view has already been added before adding it again. If the view is already added, assign the value instead of removing it.</li> <li>If you are only adding icons, consider using Spannable to construct text with mixed graphics, and directly assign it to a TextView.</li> </ol>"},{"location":"performance/#fast-scroll-throttling","title":"Fast Scroll Throttling","text":"<p>The implementation principle is similar to automatic search throttling. Delay the data loading until a certain time has passed and the item is still visible on the screen. This is because during fast scrolling, most items are displayed on the screen for a very short time and do not require data loading.</p> <pre><code>data class SimpleModel(var name: String = \"BRV\") : ItemBind, ItemAttached {\n\nprivate var itemVisible: Boolean = false\n\noverride fun onViewAttachedToWindow(holder: BindingAdapter.BindingViewHolder) {\nitemVisible = true\n}\n\noverride fun onViewDetachedFromWindow(holder: BindingAdapter.BindingViewHolder) {\nitemVisible = false\n}\n\noverride fun onBind(holder: BindingAdapter.BindingViewHolder) {\n\n\nholder.itemView.postDelayed({\nif (itemVisible) {\n// Trigger loading only if the item is still visible after 500ms\n}\n}, 500)\n}\n\n}\n</code></pre> <p>If you use Glide for image loading, you can also refer to Glide Preloading in RecyclerView, which can significantly reduce the number of \"loading\" images visible to users when scrolling through an image list.</p>"},{"location":"performance/#fixed-layout-optimization","title":"Fixed Layout Optimization","text":"<p>If the width and height of all items in the list do not change dynamically due to adapter modifications, you can use <code>setHasFixedSize(true)</code> to reduce the number of layout calculations and improve performance.</p>"},{"location":"performance/#unique-item-identifiers","title":"Unique Item Identifiers","text":"<p>Improve the performance of using <code>notifyDataSetChanged()</code> by assigning unique IDs to items in the list.</p> <pre><code>binding.rv.linear().setup {\nsetHasStableIds(true) // Enable unique IDs\naddType&lt;UserModel&gt;(R.layout.item_user)\n}.models = getData()\n</code></pre> <p>The data model should implement <code>ItemStableId</code>.</p> <pre><code>data class UserModel(var userId: Long) : ItemStableId {\n\noverride fun getItemId(): Long {\nreturn userId // Return the unique ID in the list\n}\n}\n</code></pre> <p>I hope these optimizations help improve the performance of your RecyclerView. Let me know if you have any more questions!</p>"},{"location":"preload/","title":"Preload","text":"<p>\"Preloading\" means starting to load the next page before it is displayed at the end of the list, usually triggered by the logic of \"pull up to load more.\" The prerequisite is that there is actually a next page available for the current list.</p> <p>\"Prefetching\" refers to preloading in advance. It is similar to preloading as mentioned above. If you're not familiar with the term \"pulling,\" please refer to the Upfetch documentation.</p>"},{"location":"preload/#preload-index-for-current-list","title":"Preload Index for Current List","text":"<p>BRV enables preloading/prefetching by default. You can control when the preloading/prefetching starts by specifying the member property <code>preloadIndex</code>.</p> <p>The same property is used for both preloading and prefetching. When <code>preloadIndex</code> is set, both preloading and prefetching will take effect.</p> <p>The default value is 3.</p> <pre><code>var preloadIndex = 3\n</code></pre>"},{"location":"preload/#global-preload-index","title":"Global Preload Index","text":"<p>You can set the default value for the preload index using <code>PageRefreshLayout.preloadIndex</code>. This way, all lists will start preloading/prefetching from the specified index by default.</p>"},{"location":"recycle/","title":"Recycle List","text":"<p>BRV does not require creating an Adapter, so many people may not know how to reuse similar lists. In reality, it's even simpler.</p> <p>First, familiarize yourself with the three data binding methods in BRV.</p>"},{"location":"recycle/#using-databinding","title":"Using DataBinding","text":"<p>If you're using DataBinding, it's even easier to achieve reuse. The business logic of DataBinding is contained in the Model, while the views are defined in XML files. If the UI or business logic is the same, you can register the same class and XML file.</p> <pre><code>// List 1\nrv.linear().setup {\naddType&lt;Model&gt;(R.layout.item_simple)\n}.models = getData()\n\n// List 2\nrv2.linear().setup {\naddType&lt;Model&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre>"},{"location":"recycle/#handling-data-model-differences","title":"Handling Data Model Differences","text":"<p>If the data models are different but the XML is the same, you can use the following two approaches:</p> <ol> <li>Wrap multiple classes into a single class object as the list data (everything is an object).    <pre><code>class ComposeModel(var model: Model, var model2: Model2)\n\nrv.linear().setup {\naddType&lt;ComposeModel&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre></li> <li>Have multiple classes implement a specified interface: Interface Types <pre><code>interface ModelImpl {\nvar text: String // Expose a getter function\n}\nclass Model(): ModelImpl {\noverride var text: String = \"Other text\"\n}\nclass Model2(): ModelImpl {\noverride var text: String = \"Other text\"\n}\n\nrv.linear().setup {\naddType&lt;ModelImpl&gt;(R.layout.item_simple)\n}.models = getData()\n</code></pre></li> </ol>"},{"location":"recycle/#implementing-the-itembind-interface","title":"Implementing the ItemBind Interface","text":"<p>With this data binding method, both the business logic and UI are implemented in a single function. You can reuse the same data model collection. If the UI is the same but the data is different, refer to the previous method of wrapping data models.</p> <pre><code>class SimpleModel(var name: String = \"BRV\") : ItemBind {\n\noverride fun onBind(holder: BindingAdapter.BindingViewHolder) {\nval appName = holder.context.getString(R.string.app_name)\nholder.findView&lt;TextView&gt;(R.id.tv_simple).text = appName + itemPosition\n}\n}\n</code></pre> <pre><code>// List 1\nrv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = getData()\n\n// List 2\nrv2.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple2)\n}.models = getData()\n</code></pre>"},{"location":"recycle/#using-onbind","title":"Using onBind","text":"<p>The following approach is not very convenient for reuse. It's primarily for quick and simple scenarios, and it's not recommended for complex logic. If you want to copy and paste, feel free to use it.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nonBind {\nfindView&lt;TextView&gt;(R.id.tv_simple).text = getModel&lt;SimpleModel&gt;().name\n}\n}.models = getData()\n</code></pre>"},{"location":"recycle/#extension-functions","title":"Extension Functions","text":"<p>You can encapsulate the complete code for building reusable lists as Kotlin extension functions.</p> <pre><code>/**\n * Usage\n */\nviewBinding.rv1.setupNews { }.models = listOf&lt;News1Module&gt;()\n\nval adapter = viewBinding.rv2.setupNews { }\nadapter.models = listOf&lt;News1Module&gt;()\n\n/**\n * Adapter\n */\nfun &lt;T : INews&gt; RecyclerView.setupNews(onItemContainerClick: (T) -&gt; Unit = {}): BindingAdapter =\nlinear()\n.divider(R.drawable.item_news_rv_divider)\n.setup {\naddType&lt;INews&gt;(R.layout.item_standard_news)\nonBind {\n\n}\nR.id.v_container.onClick { onItemContainerClick.invoke(getModel&lt;T&gt;()) }\n}\n\n/**\n * Define Interface\n */\ninterface INews {\nval title: String\nval image: String\nval content: String\nval url: String\nval date: String\nval time: String\n}\n\n/**\n * Entity Class 1\n */\ndata class News1Module(\nval news1Field: String,\noverride val title: String,\noverride val image: String,\noverride val content: String,\noverride val url: String,\noverride val date: String,\noverride val time: String\n) : INews\n\n/**\n * Entity Class 2\n */\ndata class News2Module(\nval news2Field: String,\nval news2Field1: String,\nval news2Field2: String,\nval news2Field3: String,\nval news2Field4: String,\nval news2Field5: String,\n) : INews {\noverride val title: String\nget() = news2Field\noverride val image: String\nget() = news2Field1\noverride val content: String\nget() = news2Field2\noverride val url: String\nget() = news2Field3\noverride val date: String\nget() = news2Field4\noverride val time: String\nget() = news2Field5\n}\n</code></pre>"},{"location":"refresh-animate/","title":"Refresh Animation","text":"<p>In the previous chapter, we introduced the integration of SmartRefreshLayout in BRV to achieve pull-down refresh and pull-up loading. The following demonstrates custom refresh animations.</p>"},{"location":"refresh-animate/#disabling-pull-up-loading-animation","title":"Disabling Pull-Up Loading Animation","text":"<p>Disabling the animation does not affect the original preloading functionality.</p> <p>Global Configuration:</p> <pre><code>SmartRefreshLayout.setDefaultRefreshFooterCreator { context, layout -&gt;\nlayout.setFooterHeight(0F)\nval classicsFooter = ClassicsFooter(context)\nclassicsFooter.visibility = View.GONE\nclassicsFooter\n}\n</code></pre> <p>Singleton Configuration, modify XML layout, or modify programmatically:</p> <pre><code>&lt;com.drake.brv.PageRefreshLayout\nandroid:id=\"@+id/page\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\napp:srlFooterHeight=\"0dp\"&gt;\n\n&lt;androidx.recyclerview.widget.RecyclerView\nandroid:id=\"@+id/rv\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\napp:layoutManager=\"androidx.recyclerview.widget.LinearLayoutManager\" /&gt;\n\n&lt;com.scwang.smart.refresh.footer.ClassicsFooter\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"0dp\" /&gt;\n\n&lt;/com.drake.brv.PageRefreshLayout&gt;\n</code></pre>"},{"location":"refresh-animate/#custom-refresh-animations","title":"Custom Refresh Animations","text":"<ul> <li>SmartRefreshLayout Custom Animation Documentation</li> </ul> <p>SmartRefresh comes with 7 animation dependency libraries that can be referenced/modified in the source code or used directly:</p> <pre><code>implementation  'io.github.scwang90:refresh-header-classics:2.0.5'    // Classic refresh header\nimplementation  'io.github.scwang90:refresh-header-radar:2.0.5'       // Radar refresh header\nimplementation  'io.github.scwang90:refresh-header-falsify:2.0.5'     // Falsify refresh header\nimplementation  'io.github.scwang90:refresh-header-material:2.0.5'    // Google refresh header\nimplementation  'io.github.scwang90:refresh-header-two-level:2.0.5'   // Two-level refresh header\nimplementation  'io.github.scwang90:refresh-footer-ball:2.0.5'        // Ball pulse loading\nimplementation  'io.github.scwang90:refresh-footer-classics:2.0.5'    // Classic loading\n</code></pre> <p>For more information, please refer to the SmartRefreshLayout homepage.</p> Personal Homepage Weibo List Food and Dining Personal Center Delivery DropBox Refresh-your-delivery [Dropbox- <p>Refresh](https://dribbble.com/shots/3470499-DropBox-Refresh)                       |</p> BezierRadar BezierCircle Pull To Refresh Pull Down To Refresh FlyRefresh Classics FlyRefresh ClassicsHeader Phoenix Taurus Yalantis/Phoenix Yalantis/Taurus BattleCity HitBlock FunGame/BattleCity FunGame/HitBlock WaveSwipe Material WaveSwipeRefreshLayout MaterialHeader StoreHouse WaterDrop CRefreshLayout WaterDrop"},{"location":"refresh-data/","title":"Data Refresh","text":"<p>BRV does not have a custom RecyclerView, so data manipulation in BRV is done in the same way as with RecyclerView. For those who are not familiar with the basics of RecyclerView, you can read this chapter and then search online for more information.</p> <p>The process of manipulating data in RecyclerView involves two steps:</p> <ol> <li>Updating the collection (adding or removing elements).</li> <li>Calling the corresponding <code>notify**()</code> methods to update the list.</li> </ol> <p>However, in BRV, assigning values to <code>models</code> or using <code>addData()</code> will automatically call <code>notifyDataChanged()</code>, so there is no need to manually update the list. If you don't want the list to be automatically updated, you can use the <code>_data</code> field in the BindingAdapter.</p> <p>The data collection in BRV, whether it's <code>models</code> or <code>addData()</code>, is of type <code>List&lt;Any?&gt;</code> (a collection of any objects). So as long as it's a collection, it can be mapped to a list.  If the data doesn't meet the requirements of a collection (or any issues with the data), please handle the data accordingly.</p>"},{"location":"refresh-data/#adding-data","title":"Adding Data","text":"<p>Using the built-in methods in BRV to add data will automatically refresh the UI.</p> <pre><code>rv.models = dataList // Automatically calls notifyDataSetChanged\nrv.addModels(newDataList) // Automatically calls notifyItemRangeInserted, animation can also be disabled\nbinding.rv.addModels(newDataList, index = 3) // Add data after index 3\n</code></pre> <p>Code Example: <pre><code>binding.rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nonBind {\nfindView&lt;TextView&gt;(R.id.tv_simple).text = getModel&lt;SimpleModel&gt;().name\n}\n}.models = getData()\n\nbinding.rv.addModels(data, index = 3) // Add data\nbinding.rv.models = newDataList // Replace the original list with new data\n</code></pre></p> <p>Remember that in Java/Kotlin, reference types are passed by reference. If both methods operate on the same data collection, it will cause issues with adding the same data to itself. This is a basic language syntax issue.</p>"},{"location":"refresh-data/#removing-data","title":"Removing Data","text":"<p>Manipulating data in BRV is the same as in RecyclerView (after all, it's just a custom Adapter). To remove all data, you can assign <code>null</code> to <code>models</code>.</p> <p>If you want to remove specific data, such as removing the second item:</p> <pre><code>rv.mutable.removeAt(2) // Remove the data first\nrv.bindingAdapter.notifyItemRemoved(2) // Then refresh the list\n</code></pre> <p>If you are removing or adding/inserting multiple items, please use the corresponding <code>notifyItem**()</code> methods. You can find the specific methods at the end of this chapter or search online.</p>"},{"location":"refresh-data/#updating-data-with-comparison","title":"Updating Data with Comparison","text":"<p>BRV can automatically use refresh animations based on the comparison of new and old data collections.</p> <pre><code>rv.setDifferModels(getRandomData())\n</code></pre> <p>This method internally uses the Android tool <code>DiffUtil</code> to compare and refresh the data. It supports synchronous and asynchronous thread comparison. <pre><code>fun setDifferModels(newModels: List&lt;Any?&gt;?, detectMoves: Boolean = true, commitCallback: Runnable? = null)\n</code></pre></p> <p>By default, data comparison uses the <code>equals</code> method. You can manually implement the <code>equals</code> method for your data to modify the comparison logic. It is recommended to define data as <code>data class</code>, as it will automatically generate <code>equals</code> based on the constructor parameters.</p> <p>If you need to completely customize the comparison logic for data, you can implement the <code>ItemDifferCallback</code> interface.</p> <pre><code>rv.linear().setup {\nadd\nType&lt;SimpleModel&gt;(R.layout.item_simple)\nitemDifferCallback = object : ItemDifferCallback {\noverride fun areContentsTheSame(oldItem: Any, newItem: Any): Boolean {\nreturn if (oldItem is SimpleModel &amp;&amp; newItem is SimpleModel) {\noldItem.name == newItem.name\n} else super.areContentsTheSame(oldItem, newItem)\n}\n}\n// ...\n}.models = getRandomData(true)\n</code></pre> <p>When using <code>setDifferModels</code> for comparison and refresh, if the same item refreshes with a blank animation, it means that <code>getChangePayload</code> returns null. Just return any object to disable it.</p> <pre><code>rv.linear().setup {\n// ...\nitemDifferCallback = object : ItemDifferCallback {\noverride fun getChangePayload(oldItem: Any, newItem: Any): Any? {\nreturn true\n}\n}\n}.models = getRandomData(true)\n</code></pre>"},{"location":"refresh-data/#partial-refresh","title":"Partial Refresh","text":"<p>To partially refresh a specific item or a batch of items, there are two approaches:</p> <ol> <li>Using methods like <code>notifyItemChanged</code>, as mentioned above.</li> <li>Utilizing the built-in feature of DataBinding (recommended), which provides the highest performance and convenience. The Check Mode in the demo is implemented using this method.</li> </ol> <p> BRV supports data binding, and if the data model used by DataBinding extends <code>Observable</code>, the UI will be automatically updated.</p> <pre><code>data class CheckModel(var checked: Boolean = false, var visibility: Boolean = false) : BaseObservable()\n</code></pre> <p>Fields that can automatically update the UI can also be used without the data model itself extending <code>BaseObservable</code>.</p> <ul> <li>LiveData</li> <li>ObservableField</li> </ul> <p>To automatically update LiveData fields, you need to configure the lifecycle for DataBinding, as LiveData observers require a lifecycle owner. <pre><code>binding.lifecycleOwner = this\n</code></pre></p> <p>These are the basics of using DataBinding. For more information, please read: Comprehensive DataBinding Guide</p>"},{"location":"refresh-data/#refresh-methods","title":"Refresh Methods","text":"<p>Here, we introduce the RecyclerView's official methods. The <code>BindingAdapter</code> in BRV inherits from <code>RecyclerView.Adapter</code>, so it naturally has access to the parent class's data refresh methods. Since many developers often ask about this requirement, let's discuss it in detail.</p> <pre><code>class BindingAdapter : RecyclerView.Adapter&lt;BindingAdapter.BindingViewHolder&gt;()\n</code></pre> Refresh Method Description notifyDataSetChanged Refreshes all data (without animation) notifyItemChanged Partially updates data notifyItemInserted Inserts an item notifyItemMoved Moves an item notifyItemRemoved Removes an item notifyItemRangeChanged Partially updates items within a specified range notifyItemRangeInserted Inserts items within a specified range notifyItemRangeRemoved Removes items within a specified range <p>You can search for \"RecyclerView partial refresh\" to learn more about the specific differences. Note that these methods refresh the UI, so if the list data hasn't changed, the refresh will have no effect.</p> <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n}.models = dataList\n\ndataList.add(SimpleModel())\n\nrv.bindingAdapter.notifyItemInserted(dataList.size) // Inserts a new item at the end\n</code></pre>"},{"location":"refresh/","title":"Pull-to-Refresh/Load-more","text":"<p>The content of this chapter may seem extensive, but the code is actually concise. The detailed explanations are omitted to avoid redundancy.</p> <p></p> <p>SmartRefreshLayout is currently the most powerful refresh framework for Android in terms of extensibility. BRV's pull-to-refresh and load-more functionalities are built on top of SmartRefreshLayout, supporting all its features and adding new ones. </p> <p>If you need more customization options for pull-to-refresh or load-more, please refer to the documentation of SmartRefreshLayout.  The <code>PageRefreshLayout</code> in this library inherits from <code>SmartRefreshLayout</code>, so it has all its features.</p> <p> This library includes the following basic dependencies of SmartRefreshLayout, so there's no need to include them again:</p> <pre><code>api 'io.github.scwang90:refresh-layout-kernel:2.0.5'\napi 'io.github.scwang90:refresh-header-material:2.0.5'\napi 'io.github.scwang90:refresh-footer-classics:2.0.5'\n</code></pre> <p>To specify custom refresh headers and footers for SmartRefreshLayout, you need to include the respective libraries (that's how SmartRefreshLayout is designed):</p> <p>Optional configurations for refresh headers and footers:</p> <pre><code>implementation  'io.github.scwang90:refresh-layout-kernel:2.0.5'      // Core dependency (must include)\nimplementation  'io.github.scwang90:refresh-header-classics:2.0.5'    // Classic refresh header\nimplementation  'io.github.scwang90:refresh-header-radar:2.0.5'       // Radar refresh header\nimplementation  'io.github.scwang90:refresh-header-falsify:2.0.5'     // Falsify refresh header\nimplementation  'io.github.scwang90:refresh-header-material:2.0.5'    // Material refresh header\nimplementation  'io.github.scwang90:refresh-header-two-level:2.0.5'   // Two-level refresh header\nimplementation  'io.github.scwang90:refresh-footer-ball:2.0.5'        // Ball pulse load-more\nimplementation  'io.github.scwang90:refresh-footer-classics:2.0.5'    // Classic load-more\n</code></pre>"},{"location":"refresh/#initialization","title":"Initialization","text":"<p>The refresh layout requires initialization first, and it's recommended to do it in the <code>Application</code> class.</p> <pre><code>SmartRefreshLayout.setDefaultRefreshHeaderCreator { context, layout -&gt; MaterialHeader(this) }\nSmartRefreshLayout.setDefaultRefreshFooterCreator { context, layout -&gt; ClassicsFooter(this) }\n</code></pre>"},{"location":"refresh/#pagerefreshlayout","title":"PageRefreshLayout","text":"<p>This control extends from <code>SmartRefreshLayout</code> and adds the following features:</p> <ol> <li>Simplified functions</li> <li>Fine-tuned details</li> <li>Empty state</li> <li>Pagination loading</li> <li>Pull-to-load-more</li> <li>Pre-loading / Pre-pulling</li> </ol>"},{"location":"refresh/#declaration","title":"Declaration","text":"<p>There are two ways to create a <code>PageRefreshLayout</code>, but it's recommended to wrap it in a layout.</p> Wrap in layout <pre><code>&lt;com.drake.brv.PageRefreshLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nxmlns:app=\"http://schemas.android.com/apk/res-auto\"\nandroid:layout_width=\"match_parent\"\nandroid:id=\"@+id/page\"\napp:stateEnabled=\"true\"\nandroid:layout_height=\"match_parent\"\ntools:context=\"com.drake.brv.sample.fragment.Refresh\n\nFragment\"&gt;\n\n&lt;androidx.recyclerview.widget.RecyclerView\nandroid:id=\"@+id/rv\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\" /&gt;\n\n&lt;/com.drake.brv.PageRefreshLayout&gt;\n</code></pre> Wrapped in code <p>It is only recommended to use layout creation, which can keep the project code readable and avoid unnecessary problems</p> <pre><code>val page = rv.pageCreate()\n</code></pre>"},{"location":"refresh/#create-the-list","title":"Create the List","text":"<pre><code>rv.linear().setup {\naddType&lt;Model&gt;(R.layout.item_simple)\naddType&lt;DoubleItemModel&gt;(R.layout.item_full_span)\n}\n\npage.onRefresh {\npostDelayed({\nval data = getData()\naddData(data) {\nindex &lt; total\n}\n}, 2000)\n}.autoRefresh()\n</code></pre> <ol> <li><code>onRefresh</code> is the function that will be executed every time the list is refreshed or loaded more.</li> </ol>"},{"location":"refresh/#listen-for-state-changes","title":"Listen for State Changes","text":"<pre><code>// Pull-to-refresh\npage.onRefresh {\n// You can perform network requests or other asynchronous operations here\n}\n\n// Load more\npage.onLoadMore {\n// You can perform network requests or other asynchronous operations here\n}\n</code></pre> <ol> <li>If you don't call <code>onLoadMore</code>, the pull-to-load-more functionality will also execute the <code>onRefresh</code> function. In most cases, pull-to-refresh and load more use the same API but with different page values.</li> </ol>"},{"location":"refresh/#trigger-refresh","title":"Trigger Refresh","text":"<p>There are three functions to trigger the refresh state (all of them will invoke the <code>onRefresh</code> function):</p> Function Description autoRefresh Show the pull-to-refresh animation showLoading Show the loading state with a custom layout refresh Refresh silently without animation refreshing Equivalent to <code>showLoading</code> for the first time. After loading is complete, it's equivalent to <code>refresh</code>. <p>All three trigger methods will reset the index to <code>startIndex</code>. The index is the default field for page increment. You will see how to use this field later.</p>"},{"location":"refresh/#empty-state","title":"Empty State","text":"<p>The <code>PageRefreshLayout</code> contains a <code>StateLayout</code> to handle the empty state.</p> <p>Control the state of the empty state layout (usually handled automatically by the framework):</p> Function Description showLoading Show the loading empty state showEmpty Show the empty empty state showError Show the error empty state showContent Show the content view"},{"location":"refresh/#global-empty-state-configuration","title":"Global Empty State Configuration","text":"<p>Global empty state configuration is shared with <code>StateLayout</code> because <code>PageRefreshLayout</code> embeds <code>StateLayout</code>.</p> <pre><code>/**\n * Recommended to configure the global empty state in the Application class.\n * For more details, refer to https://github.com/liangjingkanji/StateLayout.\n */\nStateConfig.apply {\nemptyLayout = R.layout.layout_empty\nerrorLayout = R.layout.layout_error\nloadingLayout = R.layout.layout_loading\n\nonLoading {\n// This callback is triggered when the loading layout is created. You can customize animations or click events here.\n}\n}\n</code></pre>"},{"location":"refresh/#singleton-empty-state-configuration","title":"Singleton Empty State Configuration","text":"<p>Singleton empty state means that for a specific layout, you want to use a different empty state layout instead of the global configuration. You don't need to specify all of them; you can choose to specify only the loading or error layout.</p> XML Declaration <pre><code>&lt;com.drake.brv.PageRefreshLayout\n.....\napp:error_layout=\"@layout/layout_error\"\napp:empty_layout=\"@layout/layout_empty\"\napp:loading_layout=\"@layout/layout_loading\"&gt;\n\n&lt;!--RecyclerView code--&gt;\n\n&lt;/com.drake.brv.PageRefreshLayout&gt;\n</code></pre> Code Declaration <pre><code>page.apply {\nloadingLayout = R.layout.layout_loading\nemptyLayout = R.layout.layout_empty\n// errorLayout = R.layout.layout_error\n}\n</code></pre> <p>By default, the empty state will be used. If you</p> <p>have set the global empty state and don't want to use it at this moment, you can use the <code>stateEnabled</code> property or function.</p> <p>As the header layout is part of the list and the empty state covers the entire list, if you want to use the empty state without affecting the header layout, you can use <code>CoordinatorLayout</code>.</p> <p>Note: Using <code>NestedScrollView</code> to nest the RecyclerView will load all items at once, which consumes more memory. However, nesting the RecyclerView inside a <code>CoordinatorLayout</code> won't have this issue.</p>"},{"location":"refresh/#refreshing-data","title":"Refreshing Data","text":"<p>As mentioned earlier, <code>PageRefreshLayout</code> supports automatic pagination. You don't need to use the <code>rv.models</code> function to set the data; instead, you can use <code>addData</code>.</p> <pre><code>pageLayout.onRefresh {\nscope {\nval data = Get&lt;String&gt;(\"/path\").await()\naddData(data.list) {\nadapter.itemCount &lt; data.count\n}\n}\n}\n</code></pre> <p>In most cases, the backend defines the first page as 1, but sometimes it can be 0. You can set the initial value of the <code>index</code> field (the field representing the page) in the <code>onCreate</code> method of your <code>Application</code> class.</p> <pre><code>class App : Application() {\noverride fun onCreate() {\nsuper.onCreate()\nPageRefreshLayout.startIndex = 1\n}\n}\n</code></pre> <p>In the code snippet above, I used another open-source project of mine, Net, for network requests. It can be configured together with BRV.</p> <p>If <code>PageRefreshLayout</code> is not directly wrapping the RecyclerView, you need to pass the <code>adapter</code> parameter to the <code>addData</code> function in order to use automatic pagination. Otherwise, an exception will be thrown.</p>"},{"location":"refresh/#disable-pull-to-refresh-in-empty-state","title":"Disable Pull-to-Refresh in Empty State","text":"<p>Control the PageRefreshLayout's ability to handle pull-to-refresh gestures when the empty state is displayed.</p> Function Description refreshEnableWhenEmpty Enable pull-to-refresh when the empty state is displayed refreshEnableWhenError Enable pull-to-refresh when the error state is displayed <p>The corresponding companion object properties are used for global configuration, while the object properties of PageRefreshLayout are used for singleton configuration.</p> <p>If you need more complex logic, it is recommended to use <code>PageRefreshLayout.setEnableRefresh()</code> in the empty state callback to have more control.</p>"},{"location":"state/","title":"Empty State","text":"<p>The default page is very important for a user-friendly application.</p> <p>BRV integrates a highly efficient default page library called StateLayout to implement default pages for lists.</p> <p>StateLayout is already embedded in the BRV library, so there is no need to depend on StateLayout separately. If your list includes both pull-to-refresh and load-more functionality, I recommend using PageRefreshLayout instead of StateLayout.</p> <p>Main Features:</p> <ul> <li> Elegant function design</li> <li> Partial default pages</li> <li> Layout or code declaration</li> <li> Global/singleton configuration</li> <li> Listening to default page display</li> <li> Custom animations</li> <li> Multiple state default pages</li> <li> Network request callbacks</li> <li> Passing any object as a tag</li> <li> Quick configuration for click-to-retry</li> <li> Asynchronous threads</li> <li> Immediate display of error default page when there is no network</li> <li> Automatic display of list default page when used with lists</li> <li> Automatic display of default page when used with network requests</li> </ul> <p></p>"},{"location":"state/#usage","title":"Usage","text":"<p>Step 1: Initialize the default page in your Application class.</p> <pre><code>StateConfig.apply {\nemptyLayout = R.layout.layout_empty\nerrorLayout = R.layout.layout_error\nloadingLayout = R.layout.layout_loading\n}\n</code></pre> <p>Step 2: Create the default page.</p> Layout Creation <pre><code>&lt;com.drake.statelayout.StateLayout\nandroid:id=\"@+id/state\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"&gt;\n\n&lt;androidx.recyclerview.widget.RecyclerView\nandroid:id=\"@+id/rv\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\" /&gt;\n&lt;/com.drake.statelayout.StateLayout&gt;\n</code></pre> Code Creation <p>It is recommended to create the StateLayout in XML layout to maintain code readability and avoid unnecessary issues for better performance. <pre><code>val state = stateCreate() // Create the default page function directly in the Activity/Fragment. `rv.stateCreate()` can also be used, but it is strongly discouraged.\n</code></pre></p> <p>For CoordinatorLayout+ViewPager, the root layout of the default page XML must be NestedScrollView in order to scroll correctly after displaying the default page.</p> <p>Step 3: Create the list.</p> <pre><code>rv.linear().setup {\naddType&lt;Model&gt;(R.layout.item_simple)\naddType&lt;DoubleItemModel&gt;(R.layout.item_full_span)\n}.models = getData()\n</code></pre> <p>Step 4: Show the default page.</p> <pre><code>state.showLoading()  // Show loading state\nstate.showContent() // Show content\nstate.showError() // Show error state\nstate.showEmpty() // Show empty state\n</code></pre>"},{"location":"state/#statelayout","title":"StateLayout","text":"<p>StateLayout is a highly recommended default page library. BRV internally integrates it to provide default pages for lists to developers.</p> <p>If you want to customize the default page animations and listen to the lifecycle of the default page, I recommend reading the following documentation:</p> <ul> <li>GitHub</li> <li>Documentation</li> </ul>"},{"location":"state/#skeleton-animation","title":"Skeleton Animation","text":"<p>Skeleton animation refers to the animation or image corresponding to the layout.</p> <p>BRV implements skeleton animation using StateLayout. You can refer to the [Skeleton Animation](https://liangjingkanji.github.io/</p> <p>StateLayout/skeleton/) documentation for specific implementation code examples.</p> <p>For code examples, you can refer to the sample in the BRV repository.</p>"},{"location":"swipe/","title":"Swipe","text":"<p>To enable drag and swipe functionality, you can implement the <code>ItemSwipe</code> interface for your data model:</p> <pre><code>data class SwipeModel(override var itemOrientationSwipe: Int = ItemOrientation.ALL) : ItemSwipe\n</code></pre> <p>Note that if your data model is deserialized using Gson, it will remove all the field initialization values.</p> <p>To solve this, you can override the accessor function to always return the desired value:</p> <pre><code>class SwipeModel() : ItemDrag {\noverride var itemOrientationSwipe: Int = 0\nget() = ItemOrientation.ALL // Always return this value\n}\n</code></pre>"},{"location":"swipe/#itemorientation","title":"ItemOrientation","text":"<p>This class represents the configurable drag directions.</p> Field Description <code>ALL</code> All directions <code>VERTICAL</code> Vertical direction <code>HORIZONTAL</code> Horizontal direction <code>LEFT</code> Left direction <code>RIGHT</code> Right direction <code>UP</code> Up direction <code>DOWN</code> Down direction <code>NONE</code> Disabled"},{"location":"swipe/#custom-swipe","title":"Custom Swipe","text":"<p>If you want to extend ItemTouchHelper, you can assign a value to the <code>itemTouchHelper</code> variable in the BindingAdapter:</p> <pre><code>rv.linear().setup {\naddType&lt;SwipeModel&gt;(R.layout.item)\n\nitemTouchHelper = ItemTouchHelper(object : DefaultItemTouchCallback(this) {\n// Override functions here\noverride fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {\nsuper.onSwiped(viewHolder, direction)\n// Callback after swiping, you can synchronize with the server here\n\nLog.d(\"Position\", \"layoutPosition = ${viewHolder.layoutPosition}\")\nLog.d(\"Data\", \"SwipeModel = ${(viewHolder as BindingAdapter.BindingViewHolder).getModel&lt;SwipeModel&gt;()}\")\n}\n})\n\n}.models = data\n</code></pre> <p>You can customize the view that will move during the swipe by adding the <code>swipe</code> tag to the view. This will allow you to show the view behind the background:</p> <pre><code>&lt;RelativeLayout\nandroid:layout_width=\"wrap_content\"\nandroid:layout_height=\"80dp\"\nandroid:orientation=\"horizontal\"\nandroid:tag=\"swipe\"/&gt;\n</code></pre>"},{"location":"swipe/#swipe-buttons","title":"Swipe Buttons","text":"<p>If you want to implement swipe buttons similar to the ones in the QQ app, it is recommended to use a custom item view instead of implementing it within the list.</p> <p>In this case, you can use a third-party library called SwipeToActionLayout.</p> <p></p> <p>Note that this interaction effect belongs to the official iOS effect, and it is not recommended to replicate it on Android.</p>"},{"location":"toggle/","title":"Mode Switching","text":"<p>BRV provides a toggle event trigger and listener, which can be used to iterate through all the list items. You can update the data or views in the callback function.</p> <p>The \"toggle\" can be understood as \"iterating\" through the list items.</p> <p>This feature is commonly used to switch between different editing modes in a list.</p> <p></p> <p>Here's an example:</p> <pre><code>override fun onActivityCreated(savedInstanceState: Bundle?) {\nsuper.onActivityCreated(savedInstanceState)\n\nrv.linear().setup {\naddType&lt;CheckModel&gt;(R.layout.item_check_mode)\n\n// Listen to toggle events\nonToggle { position, toggleMode, end -&gt;\nif (end) {\n// Show or hide the edit menu\nll_menu.visibility = if (toggleMode) View.VISIBLE else View.GONE\n}\n}\n}.models = getData()\n}\n\nfun onClick(v: View) {\nrv.bindingAdapter.toggle() // Trigger the toggle event on click\n}\n</code></pre> <p>Available functions:</p> <pre><code>fun toggle()\n// Trigger the toggle mode (invert the current state)\n\nfun getToggleMode(): Boolean\n// Get the current toggle mode\n\nfun setToggleMode(toggleMode: Boolean)\n// Set the toggle mode. If the provided mode is the same as the current mode, the callback won't be triggered.\n\nfun onToggle(block: (position: Int, toggleMode: Boolean, end: Boolean) -&gt; Unit)\n// Listen to toggle events. In this event, you can modify data or views as needed.\n// position: Index of the list item during the iteration\n// toggleMode: The toggle mode (Boolean)\n// end: Whether the iteration is completed for all items\n</code></pre>"},{"location":"updates/","title":"Changelog","text":""},{"location":"updates/#141","title":"1.4.1","text":"<ul> <li>feat: Added <code>copyType</code> method to preserve generics in collections, avoiding ambiguity in <code>addType</code> for distinguishing List generics.</li> </ul>"},{"location":"updates/#140","title":"1.4.0","text":"<ul> <li>refactor: If <code>models</code> is null, <code>mutable</code> returns an empty collection.</li> <li>refactor: Removed <code>isNetworkingRetry</code>.</li> <li>refactor: Removed deprecated methods.</li> <li>upgrade: Upgraded StateLayout to version 1.4.1.</li> <li>fix: #200 Dragging the first item would quickly skip the list.</li> <li>feat: Added support for repeating animations in the list.</li> </ul>"},{"location":"updates/#1390","title":"1.3.90","text":"<ul> <li>feat: #324 Grid divider spacing now supports item-based spacing.</li> <li>refactor: Removed the <code>setBackground()</code> method from <code>DefaultDecoration.kt</code> (can be replaced with the background color of the <code>rv</code>).</li> <li>fix: Fixed grid divider spacing issue.</li> </ul>"},{"location":"updates/#1389","title":"1.3.89","text":"<ul> <li>upgrade: Upgraded StateLayout to version 1.3.13.</li> <li>sample: Used mock data.</li> <li>sample: Added nested list example.</li> <li>sample: Added home layout example.</li> <li>sample: Avoided duplicate dialog display.</li> </ul>"},{"location":"updates/#1388","title":"1.3.88","text":"<ul> <li>fix: #317 Unable to drag to adjacent positions of an item (when drag state is disabled).</li> <li>fix: #305 Assigning new data to the list can restore the expanded state.</li> <li>pref: Improved expand/collapse logic.</li> <li>sample: #313 Fixed crash when deleting nested groups.</li> <li>sample: Fixed something.</li> </ul>"},{"location":"updates/#1387","title":"1.3.87","text":"<ul> <li>fix: #311 <code>notifyItemChanged</code> triggering <code>onRefresh</code>.</li> <li>pref: Optimized <code>dataBinding</code> to inflate layout only once when using non-layout bindings.</li> <li>feat: Added <code>page_upFetchEnabled</code> property.</li> <li>upgrade: Upgraded StateLayout to version 1.3.12.</li> </ul>"},{"location":"updates/#1386","title":"1.3.86","text":"<ul> <li>fix: <code>PageRefreshLayout.isNetworkingRetry</code> noop.</li> <li>feat: #292 Added <code>refreshEnableWhenEmpty</code> and <code>refreshEnableWhenError</code> properties to control pull-to-refresh when the default page is empty.</li> <li>pref: #298 <code>onCreate</code> now supports <code>itemViewType</code> values.</li> </ul>"},{"location":"updates/#1385","title":"1.3.85","text":"<ul> <li>feat: #286 Added <code>getBinding()</code> to retrieve the ViewBinding instance.</li> </ul>"},{"location":"updates/#1384","title":"1.3.84","text":"<ul> <li>fix: <code>setDifferModel</code> doesn't support inheritance from <code>ItemExpand</code> group collection data.</li> <li>fix: #281 <code>onPayload</code> didn't pass payload data collection.</li> </ul>"},{"location":"updates/#1383","title":"1.3.83","text":"<ul> <li>fix: Refreshing data caused single selection to fail.</li> <li>upgrade: Upgraded StateLayout to version 1.3.11 to fix memory leaks in <code>FadeStateChangedHandler</code>.</li> </ul>"},{"location":"updates/#1382","title":"1.3.82","text":"<ul> <li>fix: #263 Fixed custom swipe view reuse issue with <code>android:tag=\"swipe\"</code>.</li> </ul>"},{"location":"updates/#1381","title":"1.3.81","text":"<p>Fixed issue where removing items with headers during swipe deletion caused index out of bounds error.</p>"},{"location":"updates/#1380","title":"1.3.80","text":"<p>pref: <code>setRetryIds</code> now uses the most recent <code>showLoading</code> tag when clicking on retry.</p>"},{"location":"updates/#1379","title":"1.3.79","text":"<ul> <li>fix: Fixed grid divider dynamic <code>spanSize</code> spacing loss.</li> <li>feat: <code>findView</code> now supports nullable types.</li> <li>feat: Added <code>dividerSpace</code> function.</li> <li>feat: Upgraded StateLayout to version 1.3.8, introducing <code>isNetworkingRetry</code> to disable loading default page when there is no network.</li> <li>pref: Added logging for data binding failures.</li> <li>refactor: Deprecated <code>page</code> function and added</li> </ul>"},{"location":"updates/#1379_1","title":"1.3.79","text":"<ul> <li>fix: Fixed grid divider dynamic <code>spanSize</code> spacing loss.</li> <li>feat: Added <code>findView</code> method that supports nullable types.</li> <li>feat: Added <code>dividerSpace</code> function.</li> <li>feat: Upgraded StateLayout to version 1.3.8, introducing <code>isNetworkingRetry</code> to disable displaying the default loading page when there is no network.</li> <li>pref: Added logging for data binding failures.</li> <li>refactor: Deprecated the <code>page</code> function and added <code>pageCreate</code> function.</li> </ul>"},{"location":"updates/#1378","title":"1.3.78","text":"<ul> <li>feat: Added <code>page_rv</code> attribute to <code>PageRefreshLayout</code> to specify the list.</li> <li>feat: Added <code>page_state</code> layout attribute to <code>PageRefreshLayout</code> to specify the default page.</li> </ul>"},{"location":"updates/#1377","title":"1.3.77","text":"<ul> <li>feat: Upgraded StateLayout to version 1.3.6.</li> <li>feat: The <code>ACCESS_NETWORK_STATE</code> permission (to avoid displaying the loading default page without a network) can be safely removed, allowing the library to run with zero permissions.</li> </ul>"},{"location":"updates/#1376","title":"1.3.76","text":"<ul> <li>fix: Fixed inconsistency in item size when grid and spacing directions are the same.</li> </ul>"},{"location":"updates/#1375","title":"1.3.75","text":"<ul> <li>fix: Replaced <code>showEmpty</code> with \"No more loading\" message.</li> <li>fix: Improved index checking when using <code>addData</code> in <code>PageRefreshLayout</code> to avoid invalid state checking.</li> </ul>"},{"location":"updates/#1374","title":"1.3.74","text":"<ul> <li>fix: Fixed calculation error for group depth.</li> </ul>"},{"location":"updates/#1373","title":"1.3.73","text":"<ul> <li>fix: Upgraded StateLayout to version 1.3.5.</li> </ul>"},{"location":"updates/#1372","title":"1.3.72","text":"<ul> <li>refactor: Upgraded StateLayout to version 1.3.4.</li> <li>feat: Added <code>refreshing</code> parameter to <code>refresh</code> function.</li> </ul>"},{"location":"updates/#1371","title":"1.3.71","text":"<p>Fixed issue with <code>addModels</code> using index for partial updates.</p>"},{"location":"updates/#1370","title":"1.3.70","text":"<ul> <li>feat: Added <code>ItemStableId</code> to fix list IDs.</li> <li>feature #186: Added index insertion for <code>addModels</code>.</li> <li>Moved <code>ItemDepth</code> to a new position.</li> </ul>"},{"location":"updates/#1369","title":"1.3.69","text":"<p>Fixed #184: Fixed <code>setCheckableType</code>.</p>"},{"location":"updates/#1368","title":"1.3.68","text":"<ul> <li>Fixed #182.</li> <li>feat: Added singleton <code>BindingAdapter.modelId</code>.</li> <li>Increased deprecation level for APIs.</li> </ul>"},{"location":"updates/#1367","title":"1.3.67","text":"<ul> <li>feat: Added <code>ItemAttached</code>.</li> </ul>"},{"location":"updates/#1366","title":"1.3.66","text":"<ul> <li>upgrade: Upgraded StateLayout to version 1.3.3.</li> <li>feat: <code>showLoading</code> is only displayed as LOADING when there is network connectivity, without affecting <code>onRefresh</code>.</li> </ul>"},{"location":"updates/#1364","title":"1.3.64","text":"<ul> <li>upgrade: Upgraded StateLayout to version 1.3.1.</li> <li>feat: Added <code>StateChangedHandler</code> for custom default page switching.</li> <li>feat: Added <code>FadeStateChangedHandler</code> for fade-in/fade-out default page transitions.</li> <li>feat: Added <code>getBindingOrNull</code> method.</li> </ul>"},{"location":"updates/#1363","title":"1.3.63","text":"<p>Fixed #164.</p>"},{"location":"updates/#1361","title":"1.3.61","text":"<p>Fixed #157.</p>"},{"location":"updates/#1360","title":"1.3.60","text":"<p>Optional DataBinding dependency.</p>"},{"location":"updates/#1358","title":"1.3.58","text":"<p>Fixed #141.</p>"},{"location":"updates/#1357","title":"1.3.57","text":"<p>The <code>hasMore</code> parameter of <code>PageRefreshLayout.showContent</code> now defaults to <code>true</code>, to avoid unexpected disabling of the load more behavior.</p>"},{"location":"updates/#1356","title":"1.3.56","text":"<p>Fixed crash</p> <p>during refresh.</p>"},{"location":"updates/#1355","title":"1.3.55","text":"<p>Resolved issue with incorrect loading more behavior when calling <code>PageRefreshLayout.finishRefresh</code> instead of <code>SmartRefreshLayout.finishRefresh</code>.</p>"},{"location":"updates/#1354","title":"1.3.54","text":"<ul> <li>Fixed #119.</li> <li>Prevented duplicate expansion/collapse of groups.</li> <li>Fixed single expansion mode.</li> </ul>"},{"location":"updates/#1353","title":"1.3.53","text":"<ul> <li>Fixed #107.</li> <li>Fixed #108.</li> </ul>"},{"location":"updates/#1352","title":"1.3.52","text":"<p>Fixed issue with multiple loading pages being displayed, causing <code>showError</code> to be ineffective.</p>"},{"location":"updates/#1351","title":"1.3.51","text":"<ul> <li>fix: Fixed incorrect item display when dragging and dropping.</li> <li>feat: Added support for specifying <code>onClick/onFastClick/onLongClick</code> using ID directly. <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nR.id.tv_simple.onClick {\ntoast(\"Clicked Text\")\n}\n}.models = getData()\n</code></pre></li> </ul>"},{"location":"updates/#1350","title":"1.3.50","text":"<p>Updated internal dependency on SmartRefreshLayout to the latest version <code>2.0.5</code>. <pre><code>api 'io.github.scwang90:refresh-layout-kernel:2.0.5'\napi 'io.github.scwang90:refresh-header-material:2.0.5'\napi 'io.github.scwang90:refresh-footer-classics:2.0.5'\n</code></pre> Note that if you have added any additional SmartRefreshLayout refresh headers, you also need to update them to the latest <code>mavenCentral()</code> version.</p> <p>For more details, refer to #85.</p>"},{"location":"updates/#1340","title":"1.3.40","text":"<ul> <li>fix: Fixed issue with pull-to-refresh not working.</li> <li>feat: Added examples for grid grouping and drag grouping.</li> <li>feat: Optimized list load updates.</li> <li>Modified <code>addModels</code> and <code>addData</code> to maintain the same object in <code>models</code>.</li> <li>Updated example code.</li> </ul>"},{"location":"updates/#1339","title":"1.3.39","text":"<p>Exposed callback interface for comparing data changes.</p>"},{"location":"updates/#1338","title":"1.3.38","text":"<ul> <li>feat: Added <code>setDifferModels</code> function for data comparison and refresh. BRV already supports the official comparison refresh solution, but this enhancement optimizes the process.</li> <li>feat: Added <code>PageRefreshLayout.refreshing</code> to load the default page only on the first data load and use silent loading for subsequent loads.</li> </ul>"},{"location":"updates/#1337","title":"1.3.37","text":"<ul> <li>fix: Fixed reversed default page issue in UpFetch mode.</li> <li>fix: Fixed divider display issue in <code>reverseLayout</code>.</li> <li>feat: Added <code>ItemDepthUtils</code> to simplify getting the depth of grouped items.</li> </ul>"},{"location":"updates/#1336","title":"1.3.36","text":"<ul> <li>fix: Fixed divider display issue in UpFetch mode.</li> </ul>"},{"location":"updates/#1335","title":"1.3.35","text":"<ul> <li>feat: Added support for polymorphic interfaces in the <code>addType</code> function for multi-type lists.</li> <li>fix: Fixed content reversal issue on Activity with UpFetch loading.</li> </ul>"},{"location":"updates/#1334","title":"1.3.34","text":"<p>Fixed issue with duplicate data when expanding nested groups (caused by mutable child lists).</p>"},{"location":"updates/#1333","title":"1.3.33","text":"<ul> <li>fix: Fixed issue with enabling only load more.</li> <li>fix: Improved performance of parent item lookup with <code>findParentPosition</code>.</li> </ul>"},{"location":"updates/#1332","title":"1.3.32","text":"<ul> <li>feat: Allow overriding of <code>BindingAdapter</code>.</li> <li>fix: Fixed incorrect determination of no more pages when loading more.</li> </ul>"},{"location":"updates/#1331","title":"1.3.31","text":"<p>Fixed crash issue with default page in <code>PageRefreshLayout</code>.</p>"},{"location":"updates/#1330","title":"1.3.30","text":"<ol> <li>Upgraded dependency on SmartRefreshLayout to version <code>2.0.3</code>.</li> <li>Upgraded dependency on StateLayout to version <code>1.2.0</code>.</li> <li>Added <code>onContent</code> listener for default page.</li> </ol>"},{"location":"updates/#1329","title":"1.3.29","text":"<p>Hidden internal function <code>throttleClick</code>.</p>"},{"location":"updates/#1328","title":"1.3.28","text":"<p>Fixed issue with <code>onFastClick</code> not working.</p>"},{"location":"updates/#1327","title":"1.3.27","text":"<p>Configurable global interval for click debouncing.</p>"},{"location":"updates/#1326","title":"1.3.26","text":"<ul> <li>fix: Fixed incorrect parameter in <code>showLoading</code> default page.</li> <li>feat: Added <code>isSampleGroup</code> function to determine if two items are in the same group.</li> <li>feat: Improved performance of parent item lookup.</li> </ul>"},{"location":"updates/#1324","title":"1.3.24","text":"<p>Fixed issue with dynamic dividers when adding data for partial refresh.</p>"},{"location":"updates/#1322","title":"1.3.22","text":"<p>Deprecated some functions to reduce the need for checking IDs after adding click events.</p> Deprecated Function Replacement <code>addFastClickable</code> Replaced with <code>onFastClick</code> <code>addClickable</code> Replaced with <code>onClick</code> <code>addLongClickable</code> Replaced with <code>onLongClick</code>"},{"location":"updates/#1321","title":"1.3.21","text":"<p>Added support for directly calling <code>onClick/onFastClick/onLongClick</code> using ID. <pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\nR.id.tv_simple.onClick {\ntoast(\"Clicked Text\")\n}\n}.models = getData()\n</code></pre></p>"},{"location":"updates/#1320","title":"1.3.20","text":"<p>Fixed issue where singleton default page was not overriding global default page.</p>"},{"location":"upfetch/","title":"Upfetch","text":"<p>The section discusses the concept of loading more by pulling down, not by pulling up. A common use case is loading previous chat history in a chat interface.</p> <p>For example, in a chat history screen, the latest messages are at the bottom, and pulling down the list triggers loading the next page. In BRV, achieving this behavior requires just one line of code, which is an extension of SmartRefreshLayout.</p> <p></p> <p>Loading more by pulling down is essentially achieved by reversing the RecyclerView and reversing the layout of the content view (which is now displayed normally).</p> <p><pre><code>override fun onActivityCreated(savedInstanceState: Bundle?) {\nsuper.onActivityCreated(savedInstanceState)\n\nrv.setup {\naddType&lt;Model&gt;(R.layout.item_simple)\n}\n\npage.upFetchEnabled = true\npage.onRefresh {\n// Simulating a network request that succeeds after 2 seconds\npostDelayed({\nval data = getData()\naddData(data) { index &lt;= 2 }\n}, 1000)\n}.showLoading() // Show loading state (default page)\n}\n</code></pre> Except for the highlighted property, the rest of the code remains the same as usual.</p> <p>Layout code:</p> <pre><code>&lt;com.drake.brv.PageRefreshLayout\nandroid:id=\"@+id/page\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"&gt;\n\n&lt;androidx.recyclerview.widget.RecyclerView\nandroid:id=\"@+id/rv\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\napp:layoutManager=\"androidx.recyclerview.widget.LinearLayoutManager\"\napp:reverseLayout=\"true\"\napp:stackFromEnd=\"true\" /&gt;\n\n&lt;!--stackFromEnd=true ensures that when using UpFetch, the data aligns to the bottom instead of the top if it doesn't fill the screen--&gt;\n&lt;!--reverseLayout=true reverses the order of the data in the RecyclerView--&gt;\n\n&lt;/com.drake.brv.PageRefreshLayout&gt;\n</code></pre> <p>You can also use the <code>app:page_upFetchEnabled</code> attribute to configure the behavior.</p>"},{"location":"view-binding/","title":"ViewBinding","text":"<p>Assuming you don't want to use DataBinding and prefer to use ViewBinding, you can refer to the following information.</p> <p>In fact, the usage of ViewBinding for finding view objects is similar to DataBinding, as both involve calling <code>getBinding()</code>.</p>"},{"location":"view-binding/#introduction","title":"Introduction","text":"<p>It is highly recommended to use DataBinding instead of ViewBinding for the following reasons:</p> <ol> <li>MVVM with two-way data binding is currently one of the best architectural designs, and DataBinding is the optimal solution for implementing MVVM.</li> <li>ViewBinding is just a small feature within DataBinding and does not generate classes for all layouts by default, resulting in less code.</li> </ol>"},{"location":"view-binding/#usage","title":"Usage","text":"<p>If you still want to use ViewBinding, you can refer to the following code.</p>"},{"location":"view-binding/#1-using-viewbinding-in-oncreateviewholder","title":"1) Using ViewBinding in <code>onCreateViewHolder</code>","text":"<pre><code>rv.linear().setup {\naddType&lt;SimpleModel&gt;(R.layout.item_simple)\n\n// Use in the onCreateViewHolder lifecycle\nonCreate {\ngetBinding&lt;ItemSimpleBinding&gt;().tvName.text = \"Text content\"\n}\n\n// Or use in the onBindViewHolder lifecycle\nonBind {\nval binding = getBinding&lt;ItemSimpleBinding&gt;()\n}\n}.models = getData()\n</code></pre>"},{"location":"view-binding/#2-using-viewbinding-in-itembind","title":"2) Using ViewBinding in <code>ItemBind</code>","text":"<p>If you are using a data model that implements the <code>ItemBind</code> interface:</p> <pre><code>class SimpleModel(var name: String = \"BRV\") : ItemBind {\n\noverride fun onBind(holder: BindingAdapter.BindingViewHolder) {\nval binding = getBinding&lt;ItemSimpleBinding&gt;()\nbinding.tvName.text = \"Text content\"\n}\n}\n</code></pre> <p>In both cases, you can call the <code>getBinding()</code> method.</p>"},{"location":"view-binding/#multiple-types","title":"Multiple Types","text":"<p>If you have multiple item types, make sure to check the type first to avoid binding the wrong ViewBinding.</p> <pre><code>class SimpleModel(var name: String = \"BRV\") : ItemBind {\n\noverride fun onBind(holder: BindingAdapter.BindingViewHolder) {\n\n// Approach 1: Check the itemViewType\nwhen (holder.itemViewType) {\nR.layout.item_simple -&gt; {\ngetBinding&lt;ItemSimpleBinding&gt;().tvName.text = \"Text content\"\n}\nR.layout.item_simple_2 -&gt; {\ngetBinding&lt;ItemSimpleBinding2&gt;().tvName.text = \"Type 2 - Text content\"\n}\n}\n\n// Approach 2: Check the ViewBinding\nwhen (val viewBinding = getBinding&lt;ViewBinding&gt;()) {\nis ItemSimpleBinding -&gt; {\nviewBinding.tvName.text = \"Text content\"\n}\nis ItemComplexBinding -&gt; {\nviewBinding.tvName.text = \"Type 2 - Text content\"\n}\n}\n}\n}\n</code></pre>"}]}